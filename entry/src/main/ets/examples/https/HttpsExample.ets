/**
 * @fileName : HttpsExample.ets
 * @author : @cxy
 * @date : 2025/10/29
 * @description : HTTPSæœåŠ¡å™¨ç¤ºä¾‹
 */

import { fileIo } from '@kit.CoreFileKit';
import { common } from '@kit.AbilityKit';
import {
  HttpServer,
  ErrorHandler,
  ServerInfo,
  ServerEventType,
  HttpRequest,
  HttpResponse,
  NextFunction,
} from '@cxy/webserver';
import { JSON, util } from '@kit.ArkTS';

/**
 * ç”¨æˆ·æ•°æ®æ¥å£
 */
interface User {
  id: number;
  name: string;
  email?: string;
}

/**
 * HTTPSæœåŠ¡å™¨é…ç½®æ¥å£
 */
interface HttpsServerConfig {
  port: number;
  staticRoot: string;
  enableLogging: boolean;
  enableCors: boolean;
  certPath: string;
  keyPath: string;
  useSelfSigned: boolean;
}

/**
 * HTTPSæœåŠ¡å™¨ç¤ºä¾‹ç±»
 * æä¾›å®‰å…¨çš„HTTPæœåŠ¡ï¼ŒåŒ…å«SSL/TLSåŠ å¯†
 */
export class HttpsExample {
  private server: HttpServer | null = null;
  private serverInfo: ServerInfo | null = null;
  private isRunning: boolean = false;
  private config: HttpsServerConfig;
  private context: common.UIAbilityContext;
  // æ¨¡æ‹Ÿæ•°æ®å­˜å‚¨
  private users: User[] = [];
  private nextUserId: number = 1;

  constructor(context: common.UIAbilityContext, config?: Partial<HttpsServerConfig>) {
    this.context = context;
    this.config = {
      port: config?.port || 8443,
      staticRoot: config?.staticRoot || context.filesDir + '/static',
      enableLogging: config?.enableLogging || true,
      enableCors: config?.enableCors || true,
      certPath: config?.certPath || 'server-cert.pem',
      keyPath: config?.keyPath || 'server-key.pem',
      useSelfSigned: config?.useSelfSigned || true,
    };

    this.initializeData();
  }

  /**
   * è®¾ç½®é™æ€æ–‡ä»¶å’Œè¯ä¹¦
   */
  public async setupFiles(): Promise<void> {
    // è®¾ç½®é™æ€æ–‡ä»¶
    await this.setupStaticFiles();

    // è®¾ç½®SSLè¯ä¹¦
    if (this.config.useSelfSigned) {
      await this.setupSelfSignedCertificates();
    }
  }

  /**
   * åˆå§‹åŒ–æœåŠ¡å™¨
   */
  public initializeServer(): void {
    this.server = new HttpServer();

    // è®¾ç½®äº‹ä»¶å¤„ç†
    this.setupEventHandling();

    // é…ç½®ä¸­é—´ä»¶
    this.setupMiddleware();

    // é…ç½®è·¯ç”±
    this.setupRoutes();

    // è®¾ç½®å…¨å±€é”™è¯¯å¤„ç†
    this.setupGlobalErrorHandler();
  }

  /**
   * å¯åŠ¨HTTPSæœåŠ¡å™¨
   */
  public async start(): Promise<ServerInfo | null> {
    try {
      if (!this.server) {
        this.initializeServer();
      }

      if (!this.server) {
        throw new Error('HTTPSæœåŠ¡å™¨åˆå§‹åŒ–å¤±è´¥');
      }

      // æ³¨æ„ï¼šè¿™é‡Œåº”è¯¥ä½¿ç”¨TLSServerï¼Œä½†ä¸ºäº†ç¤ºä¾‹ç®€åŒ–ï¼Œä½¿ç”¨HttpServer
      // å®é™…é¡¹ç›®ä¸­éœ€è¦ï¼š
      // const tlsOptions = await CertificateManager.loadFromFiles(this.config.keyPath, this.config.certPath);
      // const httpsServer = new HttpsServer(tlsOptions);

      const info = await this.server.startServer(this.config.port);

      if (info.address) {
        this.serverInfo = info;
        this.isRunning = true;

        console.log('ğŸ”’ HTTPSæœåŠ¡å™¨å¯åŠ¨æˆåŠŸ!');
        console.log(`ğŸŒ è®¿é—®åœ°å€: https://${info.address}:${info.port}`);
        console.log('âš ï¸  æ³¨æ„: å½“å‰ä¸ºæ¼”ç¤ºæ¨¡å¼ï¼Œå®é™…HTTPSéœ€è¦é…ç½®SSLè¯ä¹¦');
        this.printApiEndpoints(info);

        return info;
      } else {
        throw new Error('æœªèƒ½è·å–æœåŠ¡å™¨åœ°å€');
      }
    } catch (error) {
      console.error('âŒ å¯åŠ¨HTTPSæœåŠ¡å™¨å¤±è´¥:', error);
      this.isRunning = false;
      return null;
    }
  }

  /**
   * åœæ­¢æœåŠ¡å™¨
   */
  public async stop(): Promise<void> {
    if (this.server && this.isRunning) {
      await this.server.stopServer();
      this.isRunning = false;
      this.serverInfo = null;
      console.log('ğŸ”’ HTTPSæœåŠ¡å™¨å·²åœæ­¢');
    }
  }

  // Getteræ–¹æ³•
  public getServerInfo(): ServerInfo | null {
    return this.serverInfo;
  }

  public getIsRunning(): boolean {
    return this.isRunning;
  }

  public getConfig(): HttpsServerConfig {
    return this.config;
  }

  /**
   * è®¾ç½®é™æ€æ–‡ä»¶
   */
  private async setupStaticFiles(): Promise<void> {
    const access = await fileIo.access(this.config.staticRoot);
    if (!access) {
      await fileIo.mkdir(this.config.staticRoot);
    }

    await this.copyStaticFile('index.html');
    await this.copyStaticFile('upload.html');
    await this.copyStaticFile('https-demo.html');
  }

  /**
   * è®¾ç½®è‡ªç­¾åè¯ä¹¦
   */
  private async setupSelfSignedCertificates(): Promise<void> {
    const certDir = `${this.context.filesDir}/certs`;

    // åˆ›å»ºè¯ä¹¦ç›®å½•
    const access = await fileIo.access(certDir);
    if (!access) {
      await fileIo.mkdir(certDir);
    }

    // ç”Ÿæˆè‡ªç­¾åè¯ä¹¦ï¼ˆå®é™…é¡¹ç›®ä¸­åº”è¯¥ä½¿ç”¨çœŸå®è¯ä¹¦ï¼‰
    await this.generateSelfSignedCert(certDir);

    this.config.certPath = `${certDir}/server-cert.pem`;
    this.config.keyPath = `${certDir}/server-key.pem`;
  }

  /**
   * åˆå§‹åŒ–æ¨¡æ‹Ÿæ•°æ®
   */
  private initializeData(): void {
    this.users = [
      { id: 1, name: 'Alice', email: 'alice@secure.com' },
      { id: 2, name: 'Bob', email: 'bob@secure.com' },
      { id: 3, name: 'Charlie', email: 'charlie@secure.com' }
    ];
    this.nextUserId = 4;
  }

  /**
   * å¤åˆ¶é™æ€æ–‡ä»¶
   */
  private async copyStaticFile(fileName: string): Promise<void> {
    try {
      const buffer = await this.context.resourceManager.getRawFileContent(fileName);
      const filePath = `${this.config.staticRoot}/${fileName}`;

      const file = await fileIo.open(filePath,
        fileIo.OpenMode.CREATE | fileIo.OpenMode.WRITE_ONLY | fileIo.OpenMode.TRUNC);
      await fileIo.write(file.fd, buffer.buffer);
      await fileIo.close(file.fd);
    } catch (error) {
      console.warn(`âš ï¸  æ— æ³•å¤åˆ¶æ–‡ä»¶ ${fileName}:`, error);
    }
  }

  /**
   * ç”Ÿæˆè‡ªç­¾åè¯ä¹¦ï¼ˆæ¼”ç¤ºç”¨ï¼‰
   */
  private async generateSelfSignedCert(certDir: string): Promise<void> {
    // è¿™é‡Œåº”è¯¥è°ƒç”¨OpenSSLæˆ–ä½¿ç”¨è¯ä¹¦ç”Ÿæˆå·¥å…·
    // ä¸ºäº†æ¼”ç¤ºï¼Œåˆ›å»ºå ä½ç¬¦æ–‡ä»¶
    const dummyCert = `-----BEGIN CERTIFICATE-----
MIIDXTCCAkWgAwIBAgIJAJC1HiIAZAiIMA0GCSqGSIb3DQEBBQUAMEUxCzAJBgNV
BAYTAkNOMRAwDgYDVQQIDAdCZWlqaW5nMRAwDgYDVQQHDAdCZWlqaW5nMRIwEAYD
VQQKDAlIYXJtb255T1MwHhcNMjUxMDI5MDAwMDAwWhcNMjYxMDI5MDAwMDAwWjBF
MQswCQYDVQQGEwJDTjEQMA4GA1UECAwHQmVpamluZzEQMA4GA1UEBwwHQmVpamlu
ZzESMBAGA1UECgwJSGFybW9ueU9TMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB
CgKCAQEA7VJTUt9Us8cKBwQANVX4Xf/XXfXXfXXfXXfXXfXXfXXfXXfXXfXXfXXf
-----END CERTIFICATE-----`;

    const dummyKey = `-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDtUlNS31SzxwoH
BAA1Vfhd/9dd9dd9dd9dd9dd9dd9dd9dd9dd9dd9dd9dd9dd9dd9dd9dd9dd9dd9d
-----END PRIVATE KEY-----`;

    // å†™å…¥è¯ä¹¦æ–‡ä»¶
    const certFile = await fileIo.open(`${certDir}/server-cert.pem`,
      fileIo.OpenMode.CREATE | fileIo.OpenMode.WRITE_ONLY | fileIo.OpenMode.TRUNC);
    await fileIo.write(certFile.fd, new util.TextEncoder().encode(dummyCert).buffer);
    await fileIo.close(certFile.fd);

    // å†™å…¥ç§é’¥æ–‡ä»¶
    const keyFile = await fileIo.open(`${certDir}/server-key.pem`,
      fileIo.OpenMode.CREATE | fileIo.OpenMode.WRITE_ONLY | fileIo.OpenMode.TRUNC);
    await fileIo.write(keyFile.fd, new util.TextEncoder().encode(dummyKey).buffer);
    await fileIo.close(keyFile.fd);

    console.log('ğŸ” è‡ªç­¾åè¯ä¹¦ç”Ÿæˆå®Œæˆï¼ˆæ¼”ç¤ºç”¨ï¼‰');
  }

  /**
   * è®¾ç½®äº‹ä»¶å¤„ç†
   */
  private setupEventHandling(): void {
    if (!this.server) {
      return;
    }

    this.server.onError((error) => {
      console.error(`ğŸš¨ HTTPSæœåŠ¡å™¨é”™è¯¯ [${error.type}]: ${JSON.stringify(error)}`);
    });

    this.server.on(ServerEventType.SERVER_STARTED, (event) => {
      console.log('ğŸ”’ HTTPSæœåŠ¡å™¨å¯åŠ¨æˆåŠŸ:', JSON.stringify(event.data));
    });

    this.server.on(ServerEventType.SERVER_STOPPED, () => {
      console.log('ğŸ”’ HTTPSæœåŠ¡å™¨å·²åœæ­¢');
    });
  }

  /**
   * é…ç½®ä¸­é—´ä»¶
   */
  private setupMiddleware(): void {
    if (!this.server) {
      return;
    }

    // å®‰å…¨å¤´éƒ¨ä¸­é—´ä»¶
    this.server.use((req: HttpRequest, res: HttpResponse, next: NextFunction) => {
      res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');
      res.setHeader('X-Content-Type-Options', 'nosniff');
      res.setHeader('X-Frame-Options', 'DENY');
      res.setHeader('X-XSS-Protection', '1; mode=block');
      next();
    });

    if (this.config.enableLogging) {
      this.server.logger({
        format: 'combined',
        stream: (log: string) => console.log(`ğŸ”’ ${log}`)
      });
    }

    if (this.config.enableCors) {
      this.server.cors({
        origin: '*',
      });
    }

    this.server.auto();
    this.server.serveStatic(this.config.staticRoot);
  }

  /**
   * é…ç½®è·¯ç”±
   */
  private setupRoutes(): void {
    this.setupSecureApiRoutes();
    this.setupSecureFileRoutes();
    this.setupSecurityRoutes();
  }

  /**
   * é…ç½®å®‰å…¨APIè·¯ç”±
   */
  private setupSecureApiRoutes(): void {
    if (!this.server) {
      return;
    }

    // å®‰å…¨ç”¨æˆ·ç®¡ç†API
    this.server.get('/api/secure/users', (req: HttpRequest, res: HttpResponse) => {
      res.json({
        users: this.users,
        secure: true,
        encryption: 'TLS 1.3',
        timestamp: new Date().toISOString()
      });
    });

    this.server.post('/api/secure/users', (req, res) => {
      const data = req.body as Record<string, string>;

      if (!data.name) {
        res.status(400).json({
          error: 'Name is required'
        });
        return
      }

      const newUser: User = {
        id: this.nextUserId++,
        name: data.name,
        email: data.email
      };

      this.users.push(newUser);

      res.status(201).json({
        message: 'Secure user created',
        user: newUser,
        secure: true
      });
    });

    // å®‰å…¨ç™»å½•API
    this.server.post('/api/secure/login', (req, res) => {
      const data = req.body as Record<string, string>;

      // æ¨¡æ‹Ÿå®‰å…¨ç™»å½•éªŒè¯
      if (data.username && data.password) {
        res.json({
          message: 'Login successful',
          token: 'secure-jwt-token-' + Date.now(),
          secure: true,
          expiresIn: '1h'
        });
      } else {
        res.status(401).json({
          error: 'Invalid credentials',
          secure: true
        });
      }
    });
  }

  /**
   * é…ç½®å®‰å…¨æ–‡ä»¶è·¯ç”±
   */
  private setupSecureFileRoutes(): void {
    if (!this.server) {
      return;
    }

    this.server.post('/api/secure/upload', async (req, res, next) => {
      try {
        const uploadedFile = req.files?.['uploadFile'];

        if (!uploadedFile) {
          return res.status(400).json({
            error: 'No file uploaded',
            secure: true
          });
        }

        const timestamp = Date.now();
        const fileName = `secure_${timestamp}_${uploadedFile.fileName}`;
        const filePath = `${this.context.filesDir}/${fileName}`;

        const file = await fileIo.open(filePath,
          fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE);
        await fileIo.write(file.fd, uploadedFile.data);
        await fileIo.close(file.fd);

        res.json({
          message: 'Secure file upload successful',
          file: {
            originalName: uploadedFile.fileName,
            savedName: fileName,
            size: uploadedFile.data.byteLength,
            encrypted: true,
            uploadTime: new Date().toISOString()
          } as ESObject
        });
      } catch (error) {
        next(error);
      }
    });
  }

  /**
   * é…ç½®å®‰å…¨ç›¸å…³è·¯ç”±
   */
  private setupSecurityRoutes(): void {
    if (!this.server) {
      return;
    }

    // SSLè¯ä¹¦ä¿¡æ¯
    this.server.get('/api/ssl/info', (req, res) => {
      res.json({
        ssl: {
          enabled: true,
          protocol: 'TLS 1.3',
          cipher: 'ECDHE-RSA-AES256-GCM-SHA384',
          certificate: {
            issuer: 'HarmonyOS Self-Signed',
            subject: 'localhost',
            validFrom: new Date().toISOString(),
            validTo: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString()
          } as ESObject
        } as ESObject,
        security: {
          hsts: true,
          xssProtection: true,
          contentTypeOptions: true,
          frameOptions: 'DENY'
        } as ESObject
      });
    });

    // å®‰å…¨æµ‹è¯•ç«¯ç‚¹
    this.server.get('/api/security/test', (req, res) => {
      res.json({
        message: 'Security test endpoint',
        secure: true,
        headers: req.headers,
        clientCert: 'Not implemented',
        timestamp: new Date().toISOString()
      });
    });
  }

  /**
   * è®¾ç½®å…¨å±€é”™è¯¯å¤„ç†
   */
  private setupGlobalErrorHandler(): void {
    if (!this.server) {
      return;
    }

    const errorHandler: ErrorHandler = (error, req, res, next) => {
      console.error(`ğŸš¨ [HTTPS Error Handler] ${req.method} ${req.path}: ${error.message}`);

      if (res.isHeadersSent()) {
        return next(error);
      }

      res.status(500).json({
        error: 'Internal Server Error',
        message: error.message,
        secure: true,
        timestamp: new Date().toISOString()
      });
    };

    this.server.use(errorHandler);
  }

  /**
   * æ‰“å°APIç«¯ç‚¹ä¿¡æ¯
   */
  private printApiEndpoints(info: ServerInfo): void {
    const baseUrl = `https://${info.address}:${info.port}`;

    console.log('\nğŸ”’ HTTPS APIç«¯ç‚¹:');
    console.log('='.repeat(50));

    console.log('ğŸ“„ é™æ€æ–‡ä»¶:');
    console.log(`   GET  ${baseUrl}/                         - å®‰å…¨é¦–é¡µ`);
    console.log(`   GET  ${baseUrl}/https-demo.html          - HTTPSæ¼”ç¤ºé¡µé¢`);

    console.log('\nğŸ” å®‰å…¨API:');
    console.log(`   GET    ${baseUrl}/api/secure/users       - å®‰å…¨ç”¨æˆ·åˆ—è¡¨`);
    console.log(`   POST   ${baseUrl}/api/secure/users       - åˆ›å»ºå®‰å…¨ç”¨æˆ·`);
    console.log(`   POST   ${baseUrl}/api/secure/login       - å®‰å…¨ç™»å½•`);
    console.log(`   POST   ${baseUrl}/api/secure/upload      - å®‰å…¨æ–‡ä»¶ä¸Šä¼ `);

    console.log('\nğŸ›¡ï¸  å®‰å…¨ä¿¡æ¯:');
    console.log(`   GET    ${baseUrl}/api/ssl/info           - SSLè¯ä¹¦ä¿¡æ¯`);
    console.log(`   GET    ${baseUrl}/api/security/test      - å®‰å…¨æµ‹è¯•`);

    console.log('='.repeat(50));
  }
}