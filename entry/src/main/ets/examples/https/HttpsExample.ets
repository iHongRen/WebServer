/**
 * @fileName : HttpsExample.ets
 * @author : @cxy
 * @date : 2025/10/29
 * @description : HTTPSæœåŠ¡å™¨ç¤ºä¾‹ - çªå‡ºSSL/TLSåŠ å¯†å’Œå®‰å…¨ç‰¹æ€§
 */

import { socket } from '@kit.NetworkKit';
import {
  TLSServer, HttpRequest, HttpResponse,
} from '@cxy/webserver';
import { common } from '@kit.AbilityKit';
import { buffer } from '@kit.ArkTS';

/**
 * HTTPSæœåŠ¡å™¨ç¤ºä¾‹ç±»
 * ä¸“æ³¨äºå±•ç¤ºHTTPSçš„æ ¸å¿ƒå®‰å…¨ç‰¹æ€§ï¼š
 * 1. SSL/TLSåŠ å¯†é€šä¿¡
 * 2. è¯ä¹¦ç®¡ç†å’ŒéªŒè¯
 * 3. å®‰å…¨å¤´éƒ¨é…ç½®
 * 4. åŠ å¯†æ•°æ®ä¼ è¾“
 */
export class HttpsExample {
  private server: TLSServer | null = null;
  private context?: common.UIAbilityContext;

  init(context: common.UIAbilityContext) {
    this.context = context
  }


  /**
   * åˆå§‹åŒ–HTTPSæœåŠ¡å™¨
   */
  public async initializeServer(): Promise<void> {
    // åŠ è½½TLSè¯ä¹¦é…ç½®
    const tlsOptions = await this.loadTLSOptions();

    // åˆ›å»ºTLSæœåŠ¡å™¨å®ä¾‹
    this.server = new TLSServer(tlsOptions);

    // é…ç½®å®‰å…¨ä¸­é—´ä»¶
    this.setupSecurityMiddleware();

    // é…ç½®HTTPSç‰¹æ€§æ¼”ç¤ºè·¯ç”±
    this.setupHttpsRoutes();
  }

  /**
   * å¯åŠ¨HTTPSæœåŠ¡å™¨
   */
  public async start(port: number): Promise<socket.NetAddress | null> {
    if (!this.server) {
      await this.initializeServer();
    }

    const info = await this.server?.startServer(port);
    if (info) {
      console.log('âœ… HTTPSæœåŠ¡å™¨å¯åŠ¨æˆåŠŸ!');
      console.log(`ğŸ”’ å®‰å…¨è®¿é—®åœ°å€: https://${info.address}:${info.port}`);
      this.printHttpsFeatures(info);
      return info;
    } else {
      console.error('âŒ å¯åŠ¨HTTPSæœåŠ¡å™¨å¤±è´¥');
      return null;
    }
  }

  /**
   * åœæ­¢æœåŠ¡å™¨
   */
  public async stop(): Promise<void> {
    if (this.server) {
      await this.server.stopServer();
      console.log('ğŸ”’ HTTPSæœåŠ¡å™¨å·²å®‰å…¨å…³é—­');
    }
  }


  // è¯»å–æ–‡ä»¶ï¼Œè§£æä¸ºå¯¹è±¡
  async readFilePath(path: string): Promise<string> {
    try {
      if (this.context) {
        const value: Uint8Array = await this.context.resourceManager.getRawFileContent(path) as Uint8Array
        return buffer.from(value.buffer).toString();
      }
    } catch (error) {
      console.error(error)
    }
    return ''
  }

  /**
   * åŠ è½½TLSè¯ä¹¦é…ç½®
   */
  private async loadTLSOptions(): Promise<socket.TLSSecureOptions> {
    try {
      // è¯ä¹¦æ–‡ä»¶è·¯å¾„ - ç”Ÿäº§ç¯å¢ƒåº”ä»å®‰å…¨å­˜å‚¨åŠ è½½
      const cert = await this.readFilePath('dev-cert.pem')
      const key = await this.readFilePath('dev-key.pem')

      // è¿”å›TLSå®‰å…¨é…ç½®
      return {
        key: key,
        cert: cert,
        // å¼ºåˆ¶ä½¿ç”¨å®‰å…¨çš„TLSåè®®ç‰ˆæœ¬
        protocols: [socket.Protocol.TLSv12, socket.Protocol.TLSv13],
        // å¯ä»¥æ·»åŠ æ›´å¤šå®‰å…¨é…ç½®
        // cipherSuite: 'ECDHE+AESGCM:ECDHE+CHACHA20:DHE+AESGCM',
      };
    } catch (error) {
      console.warn('âš ï¸ æ— æ³•åŠ è½½è¯ä¹¦æ–‡ä»¶ï¼Œä½¿ç”¨å¼€å‘ç”¨å ä½è¯ä¹¦');
      console.warn('ğŸ“ è¯·è¿è¡Œ scripts/generate-dev-cert.sh ç”Ÿæˆå¼€å‘è¯ä¹¦');

      // å¼€å‘ç¯å¢ƒå ä½è¯ä¹¦ï¼ˆä»…ç”¨äºæ¼”ç¤ºï¼‰
      return {
        key: '-----BEGIN PRIVATE KEY-----\n[å¼€å‘ç¯å¢ƒå ä½ç§é’¥]\n-----END PRIVATE KEY-----',
        cert: '-----BEGIN CERTIFICATE-----\n[å¼€å‘ç¯å¢ƒå ä½è¯ä¹¦]\n-----END CERTIFICATE-----',
      };
    }
  }


  /**
   * é…ç½®HTTPSå®‰å…¨ä¸­é—´ä»¶
   * æ¼”ç¤ºHTTPSæœåŠ¡å™¨çš„å®‰å…¨é…ç½®æœ€ä½³å®è·µ
   */
  private setupSecurityMiddleware(): void {
    if (!this.server) {
      return;
    }

    console.log('ğŸ›¡ï¸ é…ç½®HTTPSå®‰å…¨ä¸­é—´ä»¶...');

    // 1. HTTPSå®‰å…¨å¤´éƒ¨ä¸­é—´ä»¶ - æ ¸å¿ƒå®‰å…¨ç‰¹æ€§
    this.server.use((req: HttpRequest, res: HttpResponse, next: () => void) => {
      // HSTS - å¼ºåˆ¶HTTPSè®¿é—®
      res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains; preload');

      // å†…å®¹å®‰å…¨ç­–ç•¥
      res.setHeader('Content-Security-Policy', "default-src 'self'; script-src 'self' 'unsafe-inline'");

      // é˜²æ­¢MIMEç±»å‹å—…æ¢
      res.setHeader('X-Content-Type-Options', 'nosniff');

      // é˜²æ­¢ç‚¹å‡»åŠ«æŒ
      res.setHeader('X-Frame-Options', 'DENY');

      // XSSä¿æŠ¤
      res.setHeader('X-XSS-Protection', '1; mode=block');

      // å¼•ç”¨ç­–ç•¥
      res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');

      // æ ‡è®°ä¸ºå®‰å…¨ä¼ è¾“
      res.setHeader('X-Secure-Transport', 'HTTPS');

      console.log(`ğŸ”’ å®‰å…¨è¯·æ±‚: ${req.method} ${req.url} (åŠ å¯†ä¼ è¾“)`);
      next();
    });

    // 2. HTTPSè®¿é—®æ—¥å¿—ä¸­é—´ä»¶
    this.server.logger({
      format: 'combined',
      stream: (log: string) => {
        console.log(`ğŸ” [HTTPS-LOG] ${log}`);
      }
    });

    // 3. CORSé…ç½® - é’ˆå¯¹HTTPSçš„è·¨åŸŸè®¾ç½®
    this.server.cors({
      origin: '*', // å¼€å‘ç¯å¢ƒï¼Œç”Ÿäº§ç¯å¢ƒåº”é™åˆ¶ä¸ºå…·ä½“HTTPSåŸŸå
      allowedHeaders: ['Content-Type', 'Authorization', 'X-Secure-Token']
    });

    // 4. è¯·æ±‚ä½“è§£æ
    this.server.auto();
  }

  /**
   * é…ç½®HTTPSç‰¹æ€§æ¼”ç¤ºè·¯ç”±
   * é‡ç‚¹å±•ç¤ºHTTPSçš„å®‰å…¨ç‰¹æ€§å’ŒåŠ å¯†ä¼ è¾“èƒ½åŠ›
   */
  private setupHttpsRoutes(): void {
    if (!this.server) {
      return;
    }

    console.log('ğŸ”— é…ç½®HTTPSç‰¹æ€§æ¼”ç¤ºè·¯ç”±...');

    // ==================== HTTPSæ ¸å¿ƒç‰¹æ€§æ¼”ç¤º ====================

    // GET / - HTTPSé¦–é¡µï¼Œå±•ç¤ºåŠ å¯†è¿æ¥çŠ¶æ€
    this.server.get('/', (req: HttpRequest, res: HttpResponse) => {
      res.json({
        message: 'ğŸ”’ æ¬¢è¿è®¿é—®HTTPSå®‰å…¨æœåŠ¡å™¨',
        features: {
          encryption: 'SSL/TLSåŠ å¯†ä¼ è¾“',
          security: 'å®‰å…¨å¤´éƒ¨ä¿æŠ¤',
          certificate: 'X.509æ•°å­—è¯ä¹¦éªŒè¯',
          protocol: 'HTTPSåè®®'
        } as ESObject,
        connection: {
          secure: true,
          encrypted: true,
          protocol: 'HTTPS/1.1',
          timestamp: new Date().toISOString()
        } as ESObject
      });
    });

    // GET /api/ssl/info - SSL/TLSè¯ä¹¦å’ŒåŠ å¯†ä¿¡æ¯
    this.server.get('/api/ssl/info', (req: HttpRequest, res: HttpResponse) => {
      res.json({
        ssl: {
          enabled: true,
          protocol: 'TLS',
          version: '1.2+',
          cipher: 'AES256-GCM-SHA384',
          keyExchange: 'ECDHE',
          keySize: 2048,
          signatureAlgorithm: 'RSA-SHA256'
        } as ESObject,
        certificate: {
          type: 'X.509',
          selfSigned: true, // å¼€å‘ç¯å¢ƒ
          validFrom: new Date().toISOString(),
          validTo: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString(),
          subject: 'CN=localhost',
          issuer: 'CN=Dev-CA'
        } as ESObject,
        security: {
          hsts: true,
          perfectForwardSecrecy: true,
          secureRenegotiation: true,
          compression: false // é˜²æ­¢CRIMEæ”»å‡»
        } as ESObject,
        timestamp: new Date().toISOString()
      });
    });


    // GET /api/secure/token - å®‰å…¨Tokenè·å–ï¼ˆæ¼”ç¤ºHTTPSä¸‹çš„è®¤è¯ï¼‰
    this.server.get('/api/secure/token', (req: HttpRequest, res: HttpResponse) => {
      // ç®€å•çš„è®¤è¯æ£€æŸ¥
      const authHeader = req.headers?.['authorization'] as string;

      if (!authHeader || authHeader !== 'Basic ZGVtbzpzZWN1cmU=') { // demo:secure
        res.status(401).json({
          error: 'Authentication required',
          message: 'è¯·æä¾›æœ‰æ•ˆçš„è®¤è¯ä¿¡æ¯',
          note: 'HTTPSç¡®ä¿è®¤è¯ä¿¡æ¯åœ¨ä¼ è¾“è¿‡ç¨‹ä¸­è¢«åŠ å¯†ä¿æŠ¤'
        });
        return;
      }

      // ç”Ÿæˆå®‰å…¨Token
      const secureToken = `secure_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;

      res.json({
        message: 'ğŸ” å®‰å…¨Tokenå·²ç”Ÿæˆ',
        token: secureToken,
        expiresIn: 3600,
        tokenType: 'Bearer',
        secureTransport: true,
        issuedAt: new Date().toISOString(),
        note: 'Tokené€šè¿‡HTTPSå®‰å…¨ä¼ è¾“ï¼Œé˜²æ­¢ä¸­é—´äººæ”»å‡»'
      });
    });

    // GET /api/secure/verify/:token - TokenéªŒè¯ç«¯ç‚¹
    this.server.get('/api/secure/verify/:token', (req: HttpRequest, res: HttpResponse) => {
      const token = req.params['token'];

      // ç®€å•çš„TokenéªŒè¯é€»è¾‘
      const isValidToken = token && token.startsWith('secure_') && token.length > 20;

      if (isValidToken) {
        res.json({
          message: 'âœ… TokenéªŒè¯æˆåŠŸ',
          valid: true,
          token: token.substring(0, 15) + '...', // åªæ˜¾ç¤ºéƒ¨åˆ†Token
          verifiedAt: new Date().toISOString(),
          secureConnection: true,
          note: 'TokenéªŒè¯é€šè¿‡HTTPSè¿›è¡Œï¼Œç¡®ä¿éªŒè¯è¿‡ç¨‹çš„å®‰å…¨æ€§'
        });
      } else {
        res.status(401).json({
          message: 'âŒ TokenéªŒè¯å¤±è´¥',
          valid: false,
          error: 'Invalid or expired token',
          timestamp: new Date().toISOString()
        });
      }
    });

    // GET /api/security/headers - å±•ç¤ºHTTPSå®‰å…¨å¤´éƒ¨
    this.server.get('/api/security/headers', (req: HttpRequest, res: HttpResponse) => {
      // è·å–å½“å‰å“åº”çš„å®‰å…¨å¤´éƒ¨
      const securityHeaders: Record<string, string> = {
        'Strict-Transport-Security': res.getHeader('Strict-Transport-Security') || '',
        'Content-Security-Policy': res.getHeader('Content-Security-Policy') || '',
        'X-Content-Type-Options': res.getHeader('X-Content-Type-Options') || '',
        'X-Frame-Options': res.getHeader('X-Frame-Options') || '',
        'X-XSS-Protection': res.getHeader('X-XSS-Protection') || '',
        'Referrer-Policy': res.getHeader('Referrer-Policy') || ''
      };

      res.json({
        message: 'ğŸ›¡ï¸ HTTPSå®‰å…¨å¤´éƒ¨ä¿¡æ¯',
        securityHeaders,
        description: {
          'HSTS': 'å¼ºåˆ¶æµè§ˆå™¨ä½¿ç”¨HTTPSè¿æ¥',
          'CSP': 'å†…å®¹å®‰å…¨ç­–ç•¥ï¼Œé˜²æ­¢XSSæ”»å‡»',
          'X-Content-Type-Options': 'é˜²æ­¢MIMEç±»å‹å—…æ¢æ”»å‡»',
          'X-Frame-Options': 'é˜²æ­¢ç‚¹å‡»åŠ«æŒæ”»å‡»',
          'X-XSS-Protection': 'å¯ç”¨æµè§ˆå™¨XSSè¿‡æ»¤å™¨',
          'Referrer-Policy': 'æ§åˆ¶å¼•ç”¨ä¿¡æ¯çš„å‘é€'
        } as ESObject,
        httpsFeatures: [
          'ç«¯åˆ°ç«¯åŠ å¯†',
          'èº«ä»½éªŒè¯',
          'æ•°æ®å®Œæ•´æ€§',
          'é˜²é‡æ”¾æ”»å‡»',
          'å®Œç¾å‰å‘ä¿å¯†'
        ],
        timestamp: new Date().toISOString()
      });
    });
  }


  /**
   * æ‰“å°HTTPSç‰¹æ€§å’Œç«¯ç‚¹ä¿¡æ¯
   */
  private printHttpsFeatures(info: socket.NetAddress): void {
    const baseUrl = `https://${info.address}:${info.port}`;

    console.log('\nï¿½ Hç”¨TTPSå®‰å…¨ç‰¹æ€§æ¼”ç¤ºç«¯ç‚¹:');
    console.log('='.repeat(70));

    // HTTPSæ ¸å¿ƒç‰¹æ€§
    console.log('ï¿½ SSL/TLSåŠ å¯†ç‰¹æ€§:');
    console.log(`   GET  ${baseUrl}/                           - HTTPSå®‰å…¨é¦–é¡µ`);
    console.log(`   GET  ${baseUrl}/api/ssl/info               - SSLè¯ä¹¦å’ŒåŠ å¯†ä¿¡æ¯`);
    console.log(`   GET  ${baseUrl}/api/security/headers       - å®‰å…¨å¤´éƒ¨å±•ç¤º`);

    // å®‰å…¨æ•°æ®ä¼ è¾“
    console.log('\nğŸ“¡ åŠ å¯†æ•°æ®ä¼ è¾“æ¼”ç¤º:');
    console.log(`   GET  ${baseUrl}/api/secure/token           - å®‰å…¨Tokenè·å–`);
    console.log(`   GET  ${baseUrl}/api/secure/verify/secure_daffsfsfdsfdsa   - Tokenå®‰å…¨éªŒè¯`);

    console.log('\nğŸ›¡ï¸ HTTPSå®‰å…¨ç‰¹æ€§:');
    console.log('   âœ… SSL/TLSç«¯åˆ°ç«¯åŠ å¯†');
    console.log('   âœ… X.509æ•°å­—è¯ä¹¦éªŒè¯');
    console.log('   âœ… HSTSå¼ºåˆ¶HTTPSè®¿é—®');
    console.log('   âœ… å®‰å…¨å¤´éƒ¨é˜²æŠ¤');
    console.log('   âœ… å®Œç¾å‰å‘ä¿å¯†');
    console.log('   âœ… é˜²ä¸­é—´äººæ”»å‡»');

    console.log('='.repeat(70));
    console.log('âš ï¸  å¼€å‘è¯ä¹¦æç¤º: æµè§ˆå™¨ä¼šæ˜¾ç¤ºå®‰å…¨è­¦å‘Šï¼Œç‚¹å‡»"é«˜çº§"â†’"ç»§ç»­è®¿é—®"');
    console.log('ğŸ”§ æµ‹è¯•è„šæœ¬: ./test-https-api.sh');
    console.log('ï¿½ è¯ ä¹¦ç”Ÿæˆ: ./scripts/generate-dev-cert.sh');
  }
}