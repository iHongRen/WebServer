# 服务器错误处理指南

本指南介绍如何使用HarmonyOS WebServer的错误处理和事件系统，让你能够优雅地处理各种服务器错误和事件。

## 快速开始

### 基本错误监听

```typescript
import { HttpServer, ServerErrorType, ServerEventType } from '@cxy/webserver';

const server = new HttpServer();

// 监听所有错误
server.onError((error) => {
  console.error(`错误类型: ${error.type}`);
  console.error(`错误对象: ${JSON.stringfiy(error.error)}`);
});

// 启动服务器
await server.startServer(8080);
```

### 完整事件监听示例

```typescript
const server = new HttpServer();

// 错误事件监听
server.onError((error) => {
  switch (error.type) {
    case ServerErrorType.STARTUP_FAILED:
      console.error('服务器启动失败');
      break;
    case ServerErrorType.CONNECTION_ERROR:
      console.error('连接错误');
      break;
    case ServerErrorType.CLIENT_ERROR:
      console.error('客户端错误');
      break;
  }
});

// 服务器生命周期事件
server.on(ServerEventType.SERVER_STARTED, (event) => {
  console.log('服务器启动成功:', event.data);
});

server.on(ServerEventType.SERVER_STOPPED, (event) => {
  console.log('服务器已停止');
});

// 客户端连接事件
server.onClientConnect((client) => {
  console.log(`新客户端连接: ${JSON.stringfiy(client)}`);
});

server.onClientDisconnect((client) => {
  console.log(`客户端断开连接: ${JSON.stringfiy(client)}`);
});
```

## 错误类型

### ServerErrorType 枚举

| 错误类型 | 描述 | 常见原因 |
|---------|------|----------|
| `STARTUP_FAILED` | 服务器启动失败 | 端口被占用、权限不足 |
| `CONNECTION_ERROR` | 连接错误 | 网络问题、连接中断 |
| `CLIENT_ERROR` | 客户端错误 | 客户端异常断开、数据格式错误 |
| `SOCKET_ERROR` | Socket错误 | 底层Socket异常 |
| `LISTEN_ERROR` | 监听错误 | 端口绑定失败 |
| `BIND_ERROR` | 绑定错误 | 地址绑定失败 |
| `CERTIFICATE_ERROR` | 证书错误 | SSL/TLS证书问题 |
| `TLS_ERROR` | TLS错误 | TLS握手失败 |
| `UNKNOWN_ERROR` | 未知错误 | 其他未分类错误 |

### ServerError 接口

```typescript
interface ServerError {
  type: ServerErrorType; // 错误类型
  error?: Error;         // 错误对象
}
```

## 事件类型

### ServerEventType 枚举

| 事件类型 | 描述 | 触发时机 |
|---------|------|----------|
| `SERVER_STARTED` | 服务器启动 | 服务器成功启动监听 |
| `SERVER_STOPPED` | 服务器停止 | 服务器停止运行 |
| `CLIENT_CONNECTED` | 客户端连接 | 新客户端建立连接 |
| `CLIENT_DISCONNECTED` | 客户端断开 | 客户端断开连接 |
| `REQUEST_RECEIVED` | 收到请求 | 接收到HTTP请求 |
| `RESPONSE_SENT` | 发送响应 | HTTP响应发送完成 |
| `ERROR` | 错误事件 | 发生错误时 |
| `WARNING` | 警告事件 | 发生警告时 |

## 高级用法

### 错误恢复策略

```typescript
const server = new HttpServer();

server.onError((error) => {
  switch (error.type) {
    case ServerErrorType.STARTUP_FAILED:
      // 尝试其他端口
      console.log('尝试使用其他端口...');
      retryWithDifferentPort();
      break;
      
    case ServerErrorType.CONNECTION_ERROR:
      // 记录连接错误，但继续运行
      logConnectionError(error);
      break;
      
    case ServerErrorType.CLIENT_ERROR:
      // 客户端错误
     
      break;
  }
});

async function retryWithDifferentPort() {
  for (let port = 8081; port <= 8090; port++) {
    try {
      const result = await server.startServer(port);
      if (result.address) {
        console.log(`服务器在端口 ${port} 启动成功`);
        break;
      }
    } catch (e) {
      console.log(`端口 ${port} 也被占用，尝试下一个...`);
    }
  }
}
```

### 连接管理

```typescript
const server = new HttpServer();

// 连接限制
server.onClientConnect((client) => {
  if (server.getClientCount() > 100) {
    console.warn('连接数过多，断开新连接');
    server.disconnectClient(client.clientId);
  }
});

// 连接监控
setInterval(() => {
  const clients = server.getClients();
  console.log(`当前连接数: ${clients.length}`);
}, 60000); // 每分钟检查一次
```

### 

### 添加和移除监听器

```typescript
const server = new HttpServer();

// 创建监听器函数
const errorHandler = (error: ServerError) => {
  console.error('处理错误:', error.message);
};

const startHandler = (event: ServerEvent) => {
  console.log('服务器启动:', event.data);
};

// 添加监听器
server.onError(errorHandler);
server.on(ServerEventType.SERVER_STARTED, startHandler);

// 移除特定监听器
server.removeErrorListener(errorHandler);
server.removeListener(ServerEventType.SERVER_STARTED, startHandler);

// 清除所有监听器
server.removeAllListeners();
```

### 一次性监听器

```typescript
const server = new HttpServer();

// 创建一次性错误监听器
const onceErrorHandler = (error: ServerError) => {
  console.error('首次错误:', error.message);
  // 处理完后移除自己
  server.removeErrorListener(onceErrorHandler);
};

server.onError(onceErrorHandler);
```



## 注意事项

1. **避免在错误处理器中抛出异常**，这可能导致无限循环
2. **及时移除不需要的监听器**，避免内存泄漏
3. **合理设置错误处理策略**，不要忽略重要错误
4. **记录足够的上下文信息**，便于问题排查
5. **考虑错误的严重程度**，采取相应的处理措施