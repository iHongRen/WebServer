/**
 * @fileName : ErrorHandlingExample.ets
 * @author : @cxy
 * @date : 2025/10/29
 * @description : æœåŠ¡å™¨é”™è¯¯å¤„ç†ç¤ºä¾‹
 */


import {
  ServerError,
  ServerEvent,
  ServerErrorType,
  ServerEventType,
  HttpServer,
  HttpRequest,
  HttpResponse
} from '@cxy/webserver';
import { socket } from '@kit.NetworkKit';

/**
 * é”™è¯¯å¤„ç†ç¤ºä¾‹ç±»
 */
export class ErrorHandlingExample {
  /**
   * åˆ›å»ºå¸¦æœ‰å®Œæ•´é”™è¯¯å¤„ç†çš„HTTPæœåŠ¡å™¨
   */
  public static async createServerWithErrorHandling(): Promise<HttpServer> {
    const server = new HttpServer();

    // é…ç½®åŸºæœ¬ä¸­é—´ä»¶
    server.logger();
    server.cors();
    server.json();

    // ==================== é”™è¯¯äº‹ä»¶ç›‘å¬ ====================

    // ç›‘å¬æ‰€æœ‰é”™è¯¯äº‹ä»¶
    server.onError((error: ServerError) => {
      console.error(`ğŸš¨ æœåŠ¡å™¨é”™è¯¯ [${error.type}]:`, JSON.stringify(error.error));

      // æ ¹æ®é”™è¯¯ç±»å‹è¿›è¡Œä¸åŒå¤„ç†
      switch (error.type) {
        case ServerErrorType.STARTUP_FAILED:
          console.error('ğŸ’¥ æœåŠ¡å™¨å¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç«¯å£æ˜¯å¦è¢«å ç”¨');
          // å¯ä»¥åœ¨è¿™é‡Œå®ç°é‡è¯•é€»è¾‘æˆ–é€šçŸ¥ç®¡ç†å‘˜
          break;

        case ServerErrorType.LISTEN_ERROR:
          console.error('ğŸ”Œ ç«¯å£ç›‘å¬å¤±è´¥ï¼Œå¯èƒ½ç«¯å£å·²è¢«å ç”¨');
          // å¯ä»¥å°è¯•å…¶ä»–ç«¯å£
          break;

        case ServerErrorType.CONNECTION_ERROR:
          console.error('ğŸ”— è¿æ¥é”™è¯¯ï¼Œå®¢æˆ·ç«¯è¿æ¥å¼‚å¸¸');
          break;

        case ServerErrorType.CLIENT_ERROR:
          console.error('ğŸ‘¤ å®¢æˆ·ç«¯é”™è¯¯');
          break;

        case ServerErrorType.SOCKET_ERROR:
          console.error('ğŸ”Œ Socketé”™è¯¯');
          break;

        default:
          console.error('â“ æœªçŸ¥é”™è¯¯ç±»å‹');
      }
    });

    // ==================== æœåŠ¡å™¨äº‹ä»¶ç›‘å¬ ====================

    // ç›‘å¬æœåŠ¡å™¨å¯åŠ¨äº‹ä»¶
    server.on(ServerEventType.SERVER_STARTED, (event: ServerEvent) => {
      console.log('ğŸš€ æœåŠ¡å™¨å¯åŠ¨æˆåŠŸ!');
      console.log('å¯åŠ¨ä¿¡æ¯:', event.data);
      // å¯ä»¥åœ¨è¿™é‡Œå‘é€å¯åŠ¨é€šçŸ¥ã€è®°å½•æ—¥å¿—ç­‰
    });

    // ç›‘å¬æœåŠ¡å™¨åœæ­¢äº‹ä»¶
    server.on(ServerEventType.SERVER_STOPPED, (event: ServerEvent) => {
      console.log('ğŸ›‘ æœåŠ¡å™¨å·²åœæ­¢');
      // å¯ä»¥åœ¨è¿™é‡Œè¿›è¡Œæ¸…ç†å·¥ä½œã€ä¿å­˜çŠ¶æ€ç­‰
    });

    // ç›‘å¬è¯·æ±‚æ¥æ”¶äº‹ä»¶
    server.on(ServerEventType.REQUEST_RECEIVED, (event: ServerEvent) => {
      console.log(`ğŸ“¨ æ”¶åˆ°è¯·æ±‚: ${event.type}`);
      // å¯ä»¥åœ¨è¿™é‡Œè¿›è¡Œè¯·æ±‚ç»Ÿè®¡ã€é™æµç­‰
    });

    // ç›‘å¬å“åº”å‘é€äº‹ä»¶
    server.on(ServerEventType.RESPONSE_SENT, (event: ServerEvent) => {
      console.log(`ğŸ“¤ å“åº”å·²å‘é€: ${JSON.stringify(event.data)}`);
      // å¯ä»¥åœ¨è¿™é‡Œè¿›è¡Œå“åº”ç»Ÿè®¡ã€æ€§èƒ½ç›‘æ§ç­‰
    });

    // ==================== å®¢æˆ·ç«¯è¿æ¥äº‹ä»¶ç›‘å¬ ====================

    // ç›‘å¬å®¢æˆ·ç«¯è¿æ¥
    server.onClientConnect(async (client: socket.TCPSocketConnection | socket.TLSSocketConnection) => {
      const address = await client.getRemoteAddress()
      console.log(`ğŸ‘¤ æ–°å®¢æˆ·ç«¯è¿æ¥: ${client.clientId} ${address}`);
      console.log(`å½“å‰è¿æ¥æ•°: ${server.getClientCount()}`);

      // å¯ä»¥åœ¨è¿™é‡Œè¿›è¡Œè¿æ¥é™åˆ¶ã€IPç™½åå•æ£€æŸ¥ç­‰
      if (server.getClientCount() > 100) {
        console.warn('âš ï¸  è¿æ¥æ•°è¿‡å¤šï¼Œè€ƒè™‘é™åˆ¶æ–°è¿æ¥');
      }
    });

    // ç›‘å¬å®¢æˆ·ç«¯æ–­å¼€è¿æ¥
    server.onClientDisconnect(async (client: socket.TCPSocketConnection | socket.TLSSocketConnection) => {
      const address = await client.getRemoteAddress()
      console.log(`ğŸ‘‹ å®¢æˆ·ç«¯æ–­å¼€è¿æ¥: ${client.clientId} ${address}`);
      console.log(`å½“å‰è¿æ¥æ•°: ${server.getClientCount()}`);
    });

    // ==================== é…ç½®è·¯ç”± ====================
    ErrorHandlingExample.setupRoutes(server);

    return server;
  }

  /**
   * å¯åŠ¨å¸¦æœ‰é”™è¯¯å¤„ç†çš„æœåŠ¡å™¨ç¤ºä¾‹
   */
  public static async startExample(): Promise<void> {
    try {
      const server = await ErrorHandlingExample.createServerWithErrorHandling();

      // å¯åŠ¨æœåŠ¡å™¨
      const serverInfo = await server.startServer(8080);

      if (serverInfo.address) {
        console.log('âœ… æœåŠ¡å™¨å¯åŠ¨æˆåŠŸï¼Œé”™è¯¯å¤„ç†ç³»ç»Ÿå·²æ¿€æ´»');
        console.log(`ğŸ“‹ æµ‹è¯•ç«¯ç‚¹:`);
        console.log(`   - GET  http://${serverInfo.address}:${serverInfo.port}/`);
        console.log(`   - GET  http://${serverInfo.address}:${serverInfo.port}/status`);
        console.log(`   - GET  http://${serverInfo.address}:${serverInfo.port}/error`);
        console.log(`   - POST http://${serverInfo.address}:${serverInfo.port}/disconnect/:clientId`);

        // æ¼”ç¤ºé”™è¯¯å¤„ç†
        console.log('\nğŸ§ª æµ‹è¯•é”™è¯¯å¤„ç†...');

        // å°è¯•åœ¨åŒä¸€ç«¯å£å†æ¬¡å¯åŠ¨æœåŠ¡å™¨ï¼ˆåº”è¯¥å¤±è´¥ï¼‰
        setTimeout(async () => {
          console.log('å°è¯•åœ¨åŒä¸€ç«¯å£å†æ¬¡å¯åŠ¨æœåŠ¡å™¨...');
          await server.startServer(8080);
        }, 2000);

      } else {
        console.error('âŒ æœåŠ¡å™¨å¯åŠ¨å¤±è´¥');
      }

    } catch (error) {
      console.error('åˆ›å»ºæœåŠ¡å™¨æ—¶å‘ç”Ÿé”™è¯¯:', error);
    }
  }

  /**
   * æ¼”ç¤ºé«˜çº§é”™è¯¯å¤„ç†åŠŸèƒ½
   */
  public static async demonstrateAdvancedErrorHandling(): Promise<void> {
    const server = new HttpServer();

    // åˆ›å»ºè‡ªå®šä¹‰é”™è¯¯å¤„ç†å™¨
    const errorHandler = (error: ServerError) => {
      // è®°å½•åˆ°æ–‡ä»¶æˆ–å‘é€åˆ°ç›‘æ§ç³»ç»Ÿ
      console.log('ğŸ“ è®°å½•é”™è¯¯æ—¥å¿—:', JSON.stringify(error.error, null, 2));

      // æ ¹æ®é”™è¯¯ä¸¥é‡ç¨‹åº¦è¿›è¡Œä¸åŒå¤„ç†
      if (error.type === ServerErrorType.STARTUP_FAILED) {
        console.log('ğŸ”„ å°è¯•è‡ªåŠ¨æ¢å¤...');
        // å®ç°è‡ªåŠ¨é‡å¯é€»è¾‘
      }
    };

    server.onError(errorHandler);

    // æ¼”ç¤ºç§»é™¤ç›‘å¬å™¨
    setTimeout(() => {
      console.log('ğŸ—‘ï¸  ç§»é™¤é”™è¯¯ç›‘å¬å™¨');
      server.removeErrorListener(errorHandler);
    }, 10000);

    await server.startServer(8081);
  }

  /**
   * é…ç½®æµ‹è¯•è·¯ç”±
   */
  private static setupRoutes(server: HttpServer): void {
    // é¦–é¡µ
    server.get('/', (req: HttpRequest, res: HttpResponse) => {
      res.json({
        message: 'HTTPæœåŠ¡å™¨è¿è¡Œæ­£å¸¸',
        timestamp: new Date().toISOString(),
        clientCount: server.getClientCount(),
        serverRunning: server.isServerRunning()
      });
    });

    // æœåŠ¡å™¨çŠ¶æ€ç«¯ç‚¹
    server.get('/status', async (req: HttpRequest, res: HttpResponse) => {
      const clients = server.getClients().map(async client => {
        return {
          'id': client.clientId,
          'address': await client.getRemoteAddress(),
        } as Record<string, Object>
      });

      res.json({
        status: 'running',
        clientCount: server.getClientCount(),
        clients: clients,
        timestamp: new Date().toISOString()
      });
    });

    // æ¨¡æ‹Ÿé”™è¯¯çš„ç«¯ç‚¹
    server.get('/error', (req: HttpRequest, res: HttpResponse) => {
      // æ•…æ„æŠ›å‡ºé”™è¯¯æ¥æµ‹è¯•é”™è¯¯å¤„ç†
      throw new Error('è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•é”™è¯¯');
    });

    // æ–­å¼€æŒ‡å®šå®¢æˆ·ç«¯è¿æ¥
    server.post('/disconnect/:clientId', async (req: HttpRequest, res: HttpResponse) => {
      const clientId = Number(req.params['clientId']);
      const success = await server.disconnectClient(clientId);

      res.json({
        success,
        message: success ? `å®¢æˆ·ç«¯ ${clientId} å·²æ–­å¼€è¿æ¥` : `å®¢æˆ·ç«¯ ${clientId} ä¸å­˜åœ¨æˆ–æ–­å¼€å¤±è´¥`
      });
    });
  }
}