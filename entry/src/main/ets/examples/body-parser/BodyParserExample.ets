/**
 * @fileName : BodyParserExample.ets
 * @author : @cxy
 * @date : 2025/10/29
 * @description : Body Parserç¤ºä¾‹ - å±•ç¤ºå„ç§è¯·æ±‚ä½“è§£æåŠŸèƒ½
 */

import {
  HttpServer, ServerInfo, HttpRequest, HttpResponse,
} from '@cxy/webserver';

interface ParseResult {
  id: number;
  type: string;
  contentType: string;
  data: ESObject;
  timestamp: Date;
}

export class BodyParserExample {
  private server: HttpServer | null = null;
  private serverInfo: ServerInfo | null = null;
  // å­˜å‚¨è§£æç»“æœ
  private parseResults: ParseResult[] = [];
  private nextId: number = 1;

  /**
   * åˆå§‹åŒ–æœåŠ¡å™¨
   */
  public initializeServer(): void {
    this.server = new HttpServer();
    this.setupRoutes();
  }

  /**
   * å¯åŠ¨æœåŠ¡å™¨
   */
  public async start(port: number): Promise<ServerInfo | null> {
    try {
      if (!this.server) {
        this.initializeServer();
      }

      if (!this.server) {
        throw new Error('Body ParseræœåŠ¡å™¨åˆå§‹åŒ–å¤±è´¥');
      }

      const info = await this.server.startServer(port);

      if (info.address) {
        this.serverInfo = info;

        console.log('âœ… Body ParseræœåŠ¡å™¨å¯åŠ¨æˆåŠŸ!');
        console.log(`ğŸŒ è®¿é—®åœ°å€: http://${info.address}:${info.port}`);
        this.printApiEndpoints(info);

        return info;
      } else {
        throw new Error('æœªèƒ½è·å–æœåŠ¡å™¨åœ°å€');
      }
    } catch (error) {
      console.error('âŒ å¯åŠ¨Body ParseræœåŠ¡å™¨å¤±è´¥:', error);
      return null;
    }
  }

  /**
   * åœæ­¢æœåŠ¡å™¨
   */
  public async stop(): Promise<void> {
    if (this.server) {
      await this.server.stopServer();
      this.serverInfo = null;
      console.log('ğŸ›‘ Body ParseræœåŠ¡å™¨å·²åœæ­¢');
    }
  }

  // Getteræ–¹æ³•
  public getServerInfo(): ServerInfo | null {
    return this.serverInfo;
  }


  public getParseResultCount(): number {
    return this.parseResults.length;
  }


  /**
   * é…ç½®è·¯ç”±
   */
  private setupRoutes(): void {
    this.setupJsonRoutes();
    this.setupUrlencodedRoutes();
    this.setupMultipartRoutes();
    this.setupPlainTextRoutes();
    this.setupAutoRoutes();
    this.setupResultRoutes();
  }

  /**
   * JSONè§£æè·¯ç”±
   */
  private setupJsonRoutes(): void {
    if (!this.server) {
      return;
    }

    // ä½¿ç”¨JSONè§£æå™¨çš„è·¯ç”±
    this.server.json(); // å¯ç”¨JSONè§£æ

    this.server.post('/api/json', (req: HttpRequest, res: HttpResponse) => {
      const contentType = req.get('content-type') || '';

      if (!contentType.includes('application/json')) {
        res.status(400).json({
          error: 'Content-Type must be application/json',
          received: contentType
        });
        return
      }

      // è®°å½•è§£æç»“æœ
      const result: ParseResult = {
        id: this.nextId++,
        type: 'JSON',
        contentType,
        data: req.body,
        timestamp: new Date()
      };
      this.parseResults.push(result);

      res.json({
        message: 'JSONè§£ææˆåŠŸ',
        parser: 'JSON Parser',
        contentType,
        result
      });
    });
  }

  /**
   * URLç¼–ç è§£æè·¯ç”±
   */
  private setupUrlencodedRoutes(): void {
    if (!this.server) {
      return;
    }

    this.server.urlencoded(); // å¯ç”¨URLç¼–ç è§£æ

    this.server.post('/api/urlencoded', (req: HttpRequest, res: HttpResponse) => {
      const contentType = req.get('content-type') || '';

      if (!contentType.includes('application/x-www-form-urlencoded')) {
        res.status(400).json({
          error: 'Content-Type must be application/x-www-form-urlencoded',
          received: contentType
        });
        return
      }

      const result: ParseResult = {
        id: this.nextId++,
        type: 'URL-Encoded',
        contentType,
        data: req.body,
        timestamp: new Date()
      };
      this.parseResults.push(result);

      res.json({
        message: 'URLç¼–ç è§£ææˆåŠŸ',
        parser: 'URL-Encoded Parser',
        contentType,
        result
      });
    });
  }

  /**
   * å¤šéƒ¨åˆ†è¡¨å•è§£æè·¯ç”±
   */
  private setupMultipartRoutes(): void {
    if (!this.server) {
      return;
    }

    this.server.multipart(); // å¯ç”¨å¤šéƒ¨åˆ†è¡¨å•è§£æ

    this.server.post('/api/multipart', (req: HttpRequest, res: HttpResponse) => {
      const contentType = req.get('content-type') || '';

      if (!contentType.includes('multipart/form-data')) {
        res.status(400).json({
          error: 'Content-Type must be multipart/form-data',
          received: contentType
        });
        return
      }

      const result: ParseResult = {
        id: this.nextId++,
        type: 'Multipart',
        contentType,
        data: {
          body: req.body,
          files: Object.keys(req.files).map(key => ({
            'fieldName': key,
            'fileName': req.files?.[key]?.fileName,
            'size': req.files?.[key]?.data.byteLength,
            'contentType': req.files?.[key]?.contentType
          } as Record<string, Object>))
        },
        timestamp: new Date()
      };
      this.parseResults.push(result);

      res.json({
        message: 'å¤šéƒ¨åˆ†è¡¨å•è§£ææˆåŠŸ',
        parser: 'Multipart Parser',
        contentType,
        result
      });
    });
  }

  /**
   * çº¯æ–‡æœ¬è§£æè·¯ç”±
   */
  private setupPlainTextRoutes(): void {
    if (!this.server) {
      return;
    }

    this.server.plain(); // å¯ç”¨çº¯æ–‡æœ¬è§£æ

    this.server.post('/api/plain', (req: HttpRequest, res: HttpResponse) => {
      const contentType = req.get('content-type') || '';

      if (!contentType.includes('text/plain')) {
        res.status(400).json({
          error: 'Content-Type must be text/plain',
          received: contentType
        });
        return
      }

      const result: ParseResult = {
        id: this.nextId++,
        type: 'Plain Text',
        contentType,
        data: req.body,
        timestamp: new Date()
      };
      this.parseResults.push(result);

      res.json({
        message: 'çº¯æ–‡æœ¬è§£ææˆåŠŸ',
        parser: 'Plain Text Parser',
        contentType,
        parsedData: req.body,
        textLength: (req.body as string).length,
        result
      });
    });
  }

  /**
   * è‡ªåŠ¨è§£æè·¯ç”±
   */
  private setupAutoRoutes(): void {
    if (!this.server) {
      return;
    }

    this.server.auto(); // å¯ç”¨è‡ªåŠ¨è§£æ

    this.server.post('/api/auto', (req: HttpRequest, res: HttpResponse) => {
      const contentType = req.get('content-type') || '';

      let parserType = 'Unknown';
      if (contentType.includes('application/json')) {
        parserType = 'JSON (Auto)';
      } else if (contentType.includes('application/x-www-form-urlencoded')) {
        parserType = 'URL-Encoded (Auto)';
      } else if (contentType.includes('multipart/form-data')) {
        parserType = 'Multipart (Auto)';
      } else if (contentType.includes('text/plain')) {
        parserType = 'Plain Text (Auto)';
      }

      const result: ParseResult = {
        id: this.nextId++,
        type: parserType,
        contentType,
        data: req.body,
        timestamp: new Date()
      };
      this.parseResults.push(result);

      res.json({
        message: 'è‡ªåŠ¨è§£ææˆåŠŸ',
        parser: 'Auto Parser',
        detectedType: parserType,
        contentType,
        parsedData: req.body,
        hasFiles: req.files ? Object.keys(req.files).length > 0 : false,
        files: req.files ? Object.keys(req.files) : [],
        result
      });
    });
  }

  /**
   * ç»“æœæŸ¥è¯¢è·¯ç”±
   */
  private setupResultRoutes(): void {
    if (!this.server) {
      return;
    }

    // è·å–è§£æç»“æœåˆ—è¡¨
    this.server.get('/api/results', (req: HttpRequest, res: HttpResponse) => {
      const limit = parseInt(req.query.get('limit') || '20');
      const offset = parseInt(req.query.get('offset') || '0');

      const results = this.parseResults
        .slice(offset, offset + limit)
        .reverse(); // æœ€æ–°çš„åœ¨å‰

      res.json({
        results,
        total: this.parseResults.length,
        limit,
        offset,
        totalParsed: this.parseResults.length,
        byType: this.getResultsByType()
      });
    });

    // è·å–ç‰¹å®šè§£æç»“æœ
    this.server.get('/api/results/:id', (req: HttpRequest, res: HttpResponse) => {
      const id = parseInt(req.params['id']);
      const result = this.parseResults.find(r => r.id === id);

      if (result) {
        res.json({ result });
      } else {
        res.status(404).json({ error: 'Result not found', id });
      }
    });

    // æ¸…é™¤è§£æç»“æœ
    this.server.delete('/api/results', (req: HttpRequest, res: HttpResponse) => {
      const count = this.parseResults.length;
      this.parseResults = [];
      this.nextId = 1;

      res.json({
        message: 'All results cleared',
        clearedCount: count
      });
    });

  }

  /**
   * è·å–æŒ‰ç±»å‹åˆ†ç»„çš„ç»“æœç»Ÿè®¡
   */
  private getResultsByType(): Record<string, number> {
    const stats: Record<string, number> = {};
    this.parseResults.forEach(result => {
      stats[result.type] = (stats[result.type] || 0) + 1;
    });
    return stats;
  }


  /**
   * æ‰“å°APIç«¯ç‚¹ä¿¡æ¯
   */
  private printApiEndpoints(info: ServerInfo): void {
    const baseUrl = `http://${info.address}:${info.port}`;

    console.log('\nğŸ“‹ Body Parser APIç«¯ç‚¹:');
    console.log('='.repeat(50));

    console.log('\nğŸ”§ è§£æå™¨ç«¯ç‚¹:');
    console.log(`   POST   ${baseUrl}/api/json              - JSONè§£æå™¨`);
    console.log(`   POST   ${baseUrl}/api/urlencoded        - URLç¼–ç è§£æå™¨`);
    console.log(`   POST   ${baseUrl}/api/multipart         - å¤šéƒ¨åˆ†è¡¨å•è§£æå™¨`);
    console.log(`   POST   ${baseUrl}/api/plain             - çº¯æ–‡æœ¬è§£æå™¨`);
    console.log(`   POST   ${baseUrl}/api/auto              - è‡ªåŠ¨è§£æå™¨`);

    console.log('\nğŸ“Š ç»“æœç®¡ç†:');
    console.log(`   GET    ${baseUrl}/api/results           - è·å–è§£æç»“æœ`);
    console.log(`   GET    ${baseUrl}/api/results/:id       - è·å–ç‰¹å®šç»“æœ`);
    console.log(`   DELETE ${baseUrl}/api/results           - æ¸…é™¤æ‰€æœ‰ç»“æœ`);
    console.log(`   GET    ${baseUrl}/api/parsers           - è§£æå™¨ä¿¡æ¯`);

    console.log('='.repeat(50));
  }
}