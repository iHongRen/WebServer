/**
 * @fileName : BodyParserExample.ets
 * @author : @cxy
 * @date : 2025/10/29
 * @description : Body Parserç¤ºä¾‹ - å±•ç¤ºå„ç§è¯·æ±‚ä½“è§£æåŠŸèƒ½
 */

import {
  HttpServer, ServerInfo, HttpRequest, HttpResponse,
} from '@cxy/webserver';

// å®šä¹‰ç”¨äºå­˜å‚¨è§£æç»“æœçš„æ¥å£
interface ParseResult {
  id: number;
  type: string; // è§£æå™¨ç±»å‹ (e.g., 'JSON', 'URL-Encoded')
  contentType: string; // è¯·æ±‚çš„ Content-Type
  data: ESObject; // è§£æåçš„æ•°æ®
  timestamp: Date; // è§£ææ—¶é—´
}

export class BodyParserExample {
  private server: HttpServer | null = null;
  private serverInfo: ServerInfo | null = null;
  // ä½¿ç”¨æ•°ç»„å­˜å‚¨æ¯æ¬¡è¯·æ±‚çš„è§£æç»“æœï¼Œç”¨äºåœ¨UIä¸Šå±•ç¤º
  private parseResults: ParseResult[] = [];
  private nextId: number = 1; // è‡ªå¢ID

  /**
   * åˆå§‹åŒ–æœåŠ¡å™¨å®ä¾‹å’Œè·¯ç”±
   */
  public initializeServer(): void {
    this.server = new HttpServer();
    this.setupRoutes(); // é…ç½®æ‰€æœ‰APIè·¯ç”±
  }

  /**
   * å¯åŠ¨æœåŠ¡å™¨
   * @param port - ç›‘å¬çš„ç«¯å£å·
   * @returns æœåŠ¡å™¨ä¿¡æ¯æˆ– null
   */
  public async start(port: number): Promise<ServerInfo | null> {
    try {
      if (!this.server) {
        this.initializeServer();
      }

      if (!this.server) {
        throw new Error('Body ParseræœåŠ¡å™¨åˆå§‹åŒ–å¤±è´¥');
      }

      // å¯åŠ¨æœåŠ¡å™¨å¹¶ç›‘å¬æŒ‡å®šç«¯å£
      const info = await this.server.startServer(port);

      if (info.address) {
        this.serverInfo = info;

        console.log('âœ… Body ParseræœåŠ¡å™¨å¯åŠ¨æˆåŠŸ!');
        console.log(`ğŸŒ è®¿é—®åœ°å€: http://${info.address}:${info.port}`);
        this.printApiEndpoints(info); // åœ¨æ§åˆ¶å°æ‰“å°æ‰€æœ‰å¯ç”¨çš„APIç«¯ç‚¹

        return info;
      } else {
        throw new Error('æœªèƒ½è·å–æœåŠ¡å™¨åœ°å€');
      }
    } catch (error) {
      console.error('âŒ å¯åŠ¨Body ParseræœåŠ¡å™¨å¤±è´¥:', error);
      return null;
    }
  }

  /**
   * åœæ­¢æœåŠ¡å™¨
   */
  public async stop(): Promise<void> {
    if (this.server) {
      await this.server.stopServer();
      this.serverInfo = null;
      console.log('ğŸ›‘ Body ParseræœåŠ¡å™¨å·²åœæ­¢');
    }
  }

  // --- Getteræ–¹æ³• ---
  public getServerInfo(): ServerInfo | null {
    return this.serverInfo;
  }


  public getParseResultCount(): number {
    return this.parseResults.length;
  }


  /**
   * é›†ä¸­é…ç½®æ‰€æœ‰è·¯ç”±
   */
  private setupRoutes(): void {
    // ä¸ºä¸åŒç±»å‹çš„å†…å®¹åˆ†åˆ«è®¾ç½®è§£æå™¨å’Œè·¯ç”±
    this.setupJsonRoutes();
    this.setupUrlencodedRoutes();
    this.setupMultipartRoutes();
    this.setupPlainTextRoutes();
    this.setupAutoRoutes();
    // ç”¨äºæŸ¥è¯¢å’Œç®¡ç†è§£æç»“æœçš„è·¯ç”±
    this.setupResultRoutes();
  }

  /**
   * JSONè§£æè·¯ç”±: å¤„ç† application/json
   */
  private setupJsonRoutes(): void {
    if (!this.server) {
      return;
    }

    // å¯ç”¨JSONè§£æå™¨ã€‚æ­¤åæ‰€æœ‰è¯·æ±‚éƒ½ä¼šå°è¯•ç”¨JSONè§£æã€‚
    this.server.json(); // å¯ç”¨JSONè§£æ

    this.server.post('/api/json', (req: HttpRequest, res: HttpResponse) => {
      const contentType = req.get('content-type') || '';

      // ä¸¥æ ¼æ£€æŸ¥ Content-Type
      if (!contentType.includes('application/json')) {
        res.status(400).json({
          error: 'Content-Type must be application/json',
          received: contentType
        });
        return
      }

      // è®°å½•è§£æç»“æœ
      const result: ParseResult = {
        id: this.nextId++,
        type: 'JSON',
        contentType,
        data: req.body, // è§£æåçš„æ•°æ®åœ¨ req.body ä¸­
        timestamp: new Date()
      };
      this.parseResults.push(result);

      res.json({
        message: 'JSONè§£ææˆåŠŸ',
        parser: 'JSON Parser',
        contentType,
        result
      });
    });
  }

  /**
   * URLç¼–ç è§£æè·¯ç”±: å¤„ç† application/x-www-form-urlencoded
   */
  private setupUrlencodedRoutes(): void {
    if (!this.server) {
      return;
    }

    // å¯ç”¨URLç¼–ç è§£æå™¨
    this.server.urlencoded(); // å¯ç”¨URLç¼–ç è§£æ

    this.server.post('/api/urlencoded', (req: HttpRequest, res: HttpResponse) => {
      const contentType = req.get('content-type') || '';

      if (!contentType.includes('application/x-www-form-urlencoded')) {
        res.status(400).json({
          error: 'Content-Type must be application/x-www-form-urlencoded',
          received: contentType
        });
        return
      }

      const result: ParseResult = {
        id: this.nextId++,
        type: 'URL-Encoded',
        contentType,
        data: req.body, // è§£æåçš„æ•°æ®åœ¨ req.body ä¸­
        timestamp: new Date()
      };
      this.parseResults.push(result);

      res.json({
        message: 'URLç¼–ç è§£ææˆåŠŸ',
        parser: 'URL-Encoded Parser',
        contentType,
        result
      });
    });
  }

  /**
   * å¤šéƒ¨åˆ†è¡¨å•è§£æè·¯ç”±: å¤„ç† multipart/form-data (å¸¸ç”¨äºæ–‡ä»¶ä¸Šä¼ )
   */
  private setupMultipartRoutes(): void {
    if (!this.server) {
      return;
    }

    // å¯ç”¨å¤šéƒ¨åˆ†è¡¨å•è§£æå™¨
    this.server.multipart(); // å¯ç”¨å¤šéƒ¨åˆ†è¡¨å•è§£æ

    this.server.post('/api/multipart', (req: HttpRequest, res: HttpResponse) => {
      const contentType = req.get('content-type') || '';

      if (!contentType.includes('multipart/form-data')) {
        res.status(400).json({
          error: 'Content-Type must be multipart/form-data',
          received: contentType
        });
        return
      }

      const result: ParseResult = {
        id: this.nextId++,
        type: 'Multipart',
        contentType,
        data: {
          body: req.body, // è¡¨å•ä¸­çš„æ–‡æœ¬å­—æ®µåœ¨ req.body
          files: Object.keys(req.files).map(key => ({ // ä¸Šä¼ çš„æ–‡ä»¶åœ¨ req.files
            'fieldName': key,
            'fileName': req.files?.[key]?.fileName,
            'size': req.files?.[key]?.data.byteLength,
            'contentType': req.files?.[key]?.contentType
          } as Record<string, Object>))
        },
        timestamp: new Date()
      };
      this.parseResults.push(result);

      res.json({
        message: 'å¤šéƒ¨åˆ†è¡¨å•è§£ææˆåŠŸ',
        parser: 'Multipart Parser',
        contentType,
        result
      });
    });
  }

  /**
   * çº¯æ–‡æœ¬è§£æè·¯ç”±: å¤„ç† text/plain
   */
  private setupPlainTextRoutes(): void {
    if (!this.server) {
      return;
    }

    // å¯ç”¨çº¯æ–‡æœ¬è§£æå™¨
    this.server.plain(); // å¯ç”¨çº¯æ–‡æœ¬è§£æ

    this.server.post('/api/plain', (req: HttpRequest, res: HttpResponse) => {
      const contentType = req.get('content-type') || '';

      if (!contentType.includes('text/plain')) {
        res.status(400).json({
          error: 'Content-Type must be text/plain',
          received: contentType
        });
        return
      }

      const result: ParseResult = {
        id: this.nextId++,
        type: 'Plain Text',
        contentType,
        data: req.body, // è§£æåçš„æ–‡æœ¬åœ¨ req.body (string)
        timestamp: new Date()
      };
      this.parseResults.push(result);

      res.json({
        message: 'çº¯æ–‡æœ¬è§£ææˆåŠŸ',
        parser: 'Plain Text Parser',
        contentType,
        parsedData: req.body,
        textLength: (req.body as string).length,
        result
      });
    });
  }

  /**
   * è‡ªåŠ¨è§£æè·¯ç”±: æ ¹æ® Content-Type è‡ªåŠ¨é€‰æ‹©è§£æå™¨
   */
  private setupAutoRoutes(): void {
    if (!this.server) {
      return;
    }

    // å¯ç”¨è‡ªåŠ¨è§£æå™¨
    this.server.auto(); // å¯ç”¨è‡ªåŠ¨è§£æ

    this.server.post('/api/auto', (req: HttpRequest, res: HttpResponse) => {
      const contentType = req.get('content-type') || '';

      // åˆ¤æ–­æ˜¯å“ªä¸ªè§£æå™¨å¤„ç†äº†è¯·æ±‚
      let parserType = 'Unknown';
      if (contentType.includes('application/json')) {
        parserType = 'JSON (Auto)';
      } else if (contentType.includes('application/x-www-form-urlencoded')) {
        parserType = 'URL-Encoded (Auto)';
      } else if (contentType.includes('multipart/form-data')) {
        parserType = 'Multipart (Auto)';
      } else if (contentType.includes('text/plain')) {
        parserType = 'Plain Text (Auto)';
      }

      const result: ParseResult = {
        id: this.nextId++,
        type: parserType,
        contentType,
        data: req.body,
        timestamp: new Date()
      };
      this.parseResults.push(result);

      res.json({
        message: 'è‡ªåŠ¨è§£ææˆåŠŸ',
        parser: 'Auto Parser',
        detectedType: parserType,
        contentType,
        parsedData: req.body,
        hasFiles: req.files ? Object.keys(req.files).length > 0 : false,
        files: req.files ? Object.keys(req.files) : [],
        result
      });
    });
  }

  /**
   * ç»“æœæŸ¥è¯¢è·¯ç”±: ç”¨äºè·å–ã€æŸ¥è¯¢å’Œæ¸…é™¤è§£æç»“æœ
   */
  private setupResultRoutes(): void {
    if (!this.server) {
      return;
    }

    // GET /api/results - è·å–è§£æç»“æœåˆ—è¡¨ (æ”¯æŒåˆ†é¡µ)
    this.server.get('/api/results', (req: HttpRequest, res: HttpResponse) => {
      const limit = parseInt(req.query.get('limit') || '20');
      const offset = parseInt(req.query.get('offset') || '0');

      const results = this.parseResults
        .slice() // åˆ›å»ºå‰¯æœ¬ä»¥é¿å…ä¿®æ”¹åŸæ•°ç»„
        .reverse() // æœ€æ–°çš„åœ¨å‰
        .slice(offset, offset + limit);

      res.json({
        results,
        total: this.parseResults.length,
        limit,
        offset,
        totalParsed: this.parseResults.length,
        byType: this.getResultsByType()
      });
    });

    // GET /api/results/:id - è·å–ç‰¹å®šIDçš„è§£æç»“æœ
    this.server.get('/api/results/:id', (req: HttpRequest, res: HttpResponse) => {
      const id = parseInt(req.params['id']);
      const result = this.parseResults.find(r => r.id === id);

      if (result) {
        res.json({ result });
      } else {
        res.status(404).json({ error: 'Result not found', id });
      }
    });

    // DELETE /api/results - æ¸…é™¤æ‰€æœ‰è§£æç»“æœ
    this.server.delete('/api/results', (req: HttpRequest, res: HttpResponse) => {
      const count = this.parseResults.length;
      this.parseResults = [];
      this.nextId = 1;

      res.json({
        message: 'All results cleared',
        clearedCount: count
      });
    });

  }

  /**
   * è·å–æŒ‰ç±»å‹åˆ†ç»„çš„ç»“æœç»Ÿè®¡
   */
  private getResultsByType(): Record<string, number> {
    const stats: Record<string, number> = {};
    this.parseResults.forEach(result => {
      stats[result.type] = (stats[result.type] || 0) + 1;
    });
    return stats;
  }


  /**
   * åœ¨æ§åˆ¶å°æ‰“å°æ‰€æœ‰å¯ç”¨çš„APIç«¯ç‚¹ï¼Œæ–¹ä¾¿å¼€å‘è€…æµ‹è¯•
   */
  private printApiEndpoints(info: ServerInfo): void {
    const baseUrl = `http://${info.address}:${info.port}`;

    console.log('\nğŸ“‹ Body Parser APIç«¯ç‚¹:');
    console.log('='.repeat(50));

    console.log('\nğŸ”§ è§£æå™¨ç«¯ç‚¹ (POST):');
    console.log(`   ${baseUrl}/api/json`);
    console.log(`   ${baseUrl}/api/urlencoded`);
    console.log(`   ${baseUrl}/api/multipart`);
    console.log(`   ${baseUrl}/api/plain`);
    console.log(`   ${baseUrl}/api/auto`);

    console.log('\nğŸ“Š ç»“æœç®¡ç†:');
    console.log(`   GET    ${baseUrl}/api/results           - è·å–è§£æç»“æœ`);
    console.log(`   GET    ${baseUrl}/api/results/:id       - è·å–ç‰¹å®šç»“æœ`);
    console.log(`   DELETE ${baseUrl}/api/results           - æ¸…é™¤æ‰€æœ‰ç»“æœ`);

    console.log('\nğŸš€ æµ‹è¯•å‘½ä»¤:');
    console.log(`   sh ./entry/src/main/ets/examples/body-parser/test-body-parser.sh`);
    console.log('='.repeat(50));
  }
}