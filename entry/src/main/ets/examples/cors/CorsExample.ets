// /**
//  * @fileName : CorsExample.ets
//  * @author : @cxy
//  * @date : 2025/10/29
//  * @description : CORSç¤ºä¾‹ - å±•ç¤ºè·¨åŸŸèµ„æºå…±äº«åŠŸèƒ½
//  */
//
// import { fileIo } from '@kit.CoreFileKit';
// import { common } from '@kit.AbilityKit';
// import {
//   HttpServer,
//   ErrorHandler,
//   ServerInfo,
//   ServerEventType,
//   HttpRequest,
//   HttpResponse,
// } from '@cxy/webserver';
//
// /**
//  * CORSé…ç½®æ¥å£
//  */
// interface CorsConfig {
//   port: number;
//   staticRoot: string;
//   enableLogging: boolean;
//   corsOrigins: string[];
//   corsMethods: string[];
//   corsHeaders: string[];
//   corsCredentials: boolean;
// }
//
// /**
//  * CORSç¤ºä¾‹ç±»
//  * å±•ç¤ºè·¨åŸŸèµ„æºå…±äº«çš„å„ç§é…ç½®å’ŒåŠŸèƒ½
//  */
// export class CorsExample {
//   private server: HttpServer | null = null;
//   private serverInfo: ServerInfo | null = null;
//   private isRunning: boolean = false;
//   private config: CorsConfig;
//   private context: common.UIAbilityContext;
//   // CORSè¯·æ±‚ç»Ÿè®¡
//   private corsRequests: Array<{
//     id: number;
//     origin: string;
//     method: string;
//     headers: string[];
//     allowed: boolean;
//     timestamp: Date;
//   }> = [];
//   private nextId: number = 1;
//
//   constructor(context: common.UIAbilityContext, config?: Partial<CorsConfig>) {
//     this.context = context;
//     this.config = {
//       port: config?.port || 8083,
//       staticRoot: config?.staticRoot || context.filesDir + '/static',
//       enableLogging: config?.enableLogging || true,
//       corsOrigins: config?.corsOrigins || ['*'],
//       corsMethods: config?.corsMethods || ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
//       corsHeaders: config?.corsHeaders || ['Content-Type', 'Authorization', 'X-Requested-With'],
//       corsCredentials: config?.corsCredentials || true,
//     };
//   }
//
//   /**
//    * è®¾ç½®é™æ€æ–‡ä»¶
//    */
//   public async setupStaticFiles(): Promise<void> {
//     const access = await fileIo.access(this.config.staticRoot);
//     if (!access) {
//       await fileIo.mkdir(this.config.staticRoot);
//     }
//
//     await this.copyStaticFile('cors-demo.html');
//     await this.copyStaticFile('cors-test.html');
//   }
//
//   /**
//    * åˆå§‹åŒ–æœåŠ¡å™¨
//    */
//   public initializeServer(): void {
//     this.server = new HttpServer();
//
//     this.setupEventHandling();
//     this.setupMiddleware();
//     this.setupRoutes();
//     this.setupGlobalErrorHandler();
//   }
//
//   /**
//    * å¯åŠ¨æœåŠ¡å™¨
//    */
//   public async start(): Promise<ServerInfo | null> {
//     try {
//       if (!this.server) {
//         this.initializeServer();
//       }
//
//       if (!this.server) {
//         throw new Error('CORSæœåŠ¡å™¨åˆå§‹åŒ–å¤±è´¥');
//       }
//
//       const info = await this.server.startServer(this.config.port);
//
//       if (info.address) {
//         this.serverInfo = info;
//         this.isRunning = true;
//
//         console.log('âœ… CORSæœåŠ¡å™¨å¯åŠ¨æˆåŠŸ!');
//         console.log(`ğŸŒ è®¿é—®åœ°å€: http://${info.address}:${info.port}`);
//         this.printApiEndpoints(info);
//
//         return info;
//       } else {
//         throw new Error('æœªèƒ½è·å–æœåŠ¡å™¨åœ°å€');
//       }
//     } catch (error) {
//       console.error('âŒ å¯åŠ¨CORSæœåŠ¡å™¨å¤±è´¥:', error);
//       this.isRunning = false;
//       return null;
//     }
//   }
//
//   /**
//    * åœæ­¢æœåŠ¡å™¨
//    */
//   public async stop(): Promise<void> {
//     if (this.server && this.isRunning) {
//       await this.server.stopServer();
//       this.isRunning = false;
//       this.serverInfo = null;
//       console.log('ğŸ›‘ CORSæœåŠ¡å™¨å·²åœæ­¢');
//     }
//   }
//
//   // Getteræ–¹æ³•
//   public getServerInfo(): ServerInfo | null {
//     return this.serverInfo;
//   }
//
//   public getIsRunning(): boolean {
//     return this.isRunning;
//   }
//
//   public getConfig(): CorsConfig {
//     return this.config;
//   }
//
//   public getCorsRequestCount(): number {
//     return this.corsRequests.length;
//   }
//
//   /**
//    * å¤åˆ¶é™æ€æ–‡ä»¶
//    */
//   private async copyStaticFile(fileName: string): Promise<void> {
//     try {
//       const buffer = await this.context.resourceManager.getRawFileContent(fileName);
//       const filePath = `${this.config.staticRoot}/${fileName}`;
//
//       const file = await fileIo.open(filePath,
//         fileIo.OpenMode.CREATE | fileIo.OpenMode.WRITE_ONLY | fileIo.OpenMode.TRUNC);
//       await fileIo.write(file.fd, buffer.buffer);
//       await fileIo.close(file.fd);
//     } catch (error) {
//       console.warn(`âš ï¸  æ— æ³•å¤åˆ¶æ–‡ä»¶ ${fileName}:`, error);
//     }
//   }
//
//   /**
//    * è®¾ç½®äº‹ä»¶å¤„ç†
//    */
//   private setupEventHandling(): void {
//     if (!this.server) {
//       return;
//     }
//
//     this.server.onError((error) => {
//       console.error(`ğŸš¨ CORSæœåŠ¡å™¨é”™è¯¯ [${error.type}]: ${JSON.stringify(error.error)}`);
//     });
//
//     this.server.on(ServerEventType.SERVER_STARTED, (event) => {
//       console.log('âœ… CORSæœåŠ¡å™¨å¯åŠ¨æˆåŠŸ:', event.data);
//     });
//   }
//
//   /**
//    * é…ç½®ä¸­é—´ä»¶
//    */
//   private setupMiddleware(): void {
//     if (!this.server) {
//       return;
//     }
//
//     if (this.config.enableLogging) {
//       this.server.logger({
//         format: 'dev',
//         stream: (log: string) => console.log(`ğŸŒ ${log}`)
//       });
//     }
//
//     // è‡ªå®šä¹‰CORSä¸­é—´ä»¶ï¼Œç”¨äºè®°å½•CORSè¯·æ±‚
//     this.server.use((req, res, next) => {
//       const origin = req.get('origin') || req.get('referer') || 'unknown';
//       const method = req.method;
//       const requestedHeaders = req.get('access-control-request-headers')?.split(',') || [];
//
//       // è®°å½•CORSè¯·æ±‚
//       const corsRequest = {
//         id: this.nextId++,
//         origin,
//         method,
//         headers: requestedHeaders,
//         allowed: this.isOriginAllowed(origin),
//         timestamp: new Date()
//       };
//       this.corsRequests.push(corsRequest);
//
//       console.log(`ğŸŒ CORSè¯·æ±‚: ${method} from ${origin} - ${corsRequest.allowed ? 'âœ… å…è®¸' : 'âŒ æ‹’ç»'}`);
//
//       next();
//     });
//
//     // é…ç½®CORS
//     this.server.cors({
//       origin: this.config.corsOrigins,
//       methods: this.config.corsMethods,
//       allowedHeaders: this.config.corsHeaders
//     });
//
//     this.server.auto();
//     this.server.serveStatic(this.config.staticRoot);
//   }
//
//   /**
//    * æ£€æŸ¥æ¥æºæ˜¯å¦è¢«å…è®¸
//    */
//   private isOriginAllowed(origin: string): boolean {
//     if (this.config.corsOrigins.includes('*')) {
//       return true;
//     }
//     return this.config.corsOrigins.some(allowed =>
//     origin.includes(allowed) || allowed.includes(origin)
//     );
//   }
//
//   /**
//    * é…ç½®è·¯ç”±
//    */
//   private setupRoutes(): void {
//     this.setupCorsTestRoutes();
//     this.setupCorsConfigRoutes();
//     this.setupCorsStatsRoutes();
//   }
//
//   /**
//    * CORSæµ‹è¯•è·¯ç”±
//    */
//   private setupCorsTestRoutes(): void {
//     if (!this.server) {
//       return;
//     }
//
//     // ç®€å•è¯·æ±‚æµ‹è¯•
//     this.server.get('/api/cors/simple', (req: HttpRequest, res: HttpResponse) => {
//       const origin = req.get('origin') || 'unknown';
//
//       res.json({
//         message: 'CORSç®€å•è¯·æ±‚æµ‹è¯•æˆåŠŸ',
//         origin,
//         method: req.method,
//         timestamp: new Date().toISOString(),
//         corsType: 'Simple Request'
//       });
//     });
//
//     // é¢„æ£€è¯·æ±‚æµ‹è¯•
//     this.server.post('/api/cors/preflight', (req: HttpRequest, res: HttpResponse) => {
//       const origin = req.get('origin') || 'unknown';
//
//       res.json({
//         message: 'CORSé¢„æ£€è¯·æ±‚æµ‹è¯•æˆåŠŸ',
//         origin,
//         method: req.method,
//         body: req.body,
//         timestamp: new Date().toISOString(),
//         corsType: 'Preflight Request'
//       });
//     });
//
//     // å¸¦å‡­è¯çš„è¯·æ±‚æµ‹è¯•
//     this.server.post('/api/cors/credentials', (req: HttpRequest, res: HttpResponse) => {
//       const origin = req.get('origin') || 'unknown';
//       const cookies = req.get('cookie') || 'none';
//
//       // è®¾ç½®ä¸€ä¸ªæµ‹è¯•cookie
//       res.setHeader('Set-Cookie', 'cors-test=success; Path=/; HttpOnly');
//
//       res.json({
//         message: 'CORSå‡­è¯è¯·æ±‚æµ‹è¯•æˆåŠŸ',
//         origin,
//         cookies,
//         credentialsSupported: this.config.corsCredentials,
//         timestamp: new Date().toISOString(),
//         corsType: 'Credentialed Request'
//       });
//     });
//
//     // è‡ªå®šä¹‰å¤´éƒ¨æµ‹è¯•
//     this.server.put('/api/cors/custom-headers', (req: HttpRequest, res: HttpResponse) => {
//       const origin = req.get('origin') || 'unknown';
//       const customHeader = req.get('x-custom-header') || 'none';
//       const authorization = req.get('authorization') || 'none';
//
//       res.json({
//         message: 'CORSè‡ªå®šä¹‰å¤´éƒ¨æµ‹è¯•æˆåŠŸ',
//         origin,
//         customHeader,
//         authorization,
//         allowedHeaders: this.config.corsHeaders,
//         timestamp: new Date().toISOString(),
//         corsType: 'Custom Headers Request'
//       });
//     });
//   }
//
//   /**
//    * CORSé…ç½®è·¯ç”±
//    */
//   private setupCorsConfigRoutes(): void {
//     if (!this.server) {
//       return;
//     }
//
//     // è·å–CORSé…ç½®
//     this.server.get('/api/cors/config', (req: HttpRequest, res: HttpResponse) => {
//       res.json({
//         corsConfig: {
//           origins: this.config.corsOrigins,
//           methods: this.config.corsMethods,
//           headers: this.config.corsHeaders,
//           credentials: this.config.corsCredentials
//         },
//         description: {
//           origins: 'Allowed origins for CORS requests',
//           methods: 'Allowed HTTP methods',
//           headers: 'Allowed request headers',
//           credentials: 'Whether credentials are supported'
//         }
//       });
//     });
//
//     // æ›´æ–°CORSé…ç½®
//     this.server.post('/api/cors/config', (req: HttpRequest, res: HttpResponse) => {
//       const { origins, methods, headers, credentials } = req.body as any;
//
//       if (origins) {
//         this.config.corsOrigins = origins;
//       }
//       if (methods) {
//         this.config.corsMethods = methods;
//       }
//       if (headers) {
//         this.config.corsHeaders = headers;
//       }
//       if (credentials !== undefined) {
//         this.config.corsCredentials = credentials;
//       }
//
//       res.json({
//         message: 'CORSé…ç½®å·²æ›´æ–°',
//         newConfig: {
//           origins: this.config.corsOrigins,
//           methods: this.config.corsMethods,
//           headers: this.config.corsHeaders,
//           credentials: this.config.corsCredentials
//         },
//         note: 'éœ€è¦é‡å¯æœåŠ¡å™¨ä»¥åº”ç”¨æ–°é…ç½®'
//       });
//     });
//
//     // æµ‹è¯•ç‰¹å®šæ¥æº
//     this.server.post('/api/cors/test-origin', (req: HttpRequest, res: HttpResponse) => {
//       const { testOrigin } = req.body as { testOrigin: string };
//       const allowed = this.isOriginAllowed(testOrigin);
//
//       res.json({
//         origin: testOrigin,
//         allowed,
//         reason: allowed ? 'Origin is in allowed list' : 'Origin not in allowed list',
//         allowedOrigins: this.config.corsOrigins
//       });
//     });
//   }
//
//   /**
//    * CORSç»Ÿè®¡è·¯ç”±
//    */
//   private setupCorsStatsRoutes(): void {
//     if (!this.server) {
//       return;
//     }
//
//     // è·å–CORSè¯·æ±‚ç»Ÿè®¡
//     this.server.get('/api/cors/stats', (req: HttpRequest, res: HttpResponse) => {
//       const stats = this.analyzeCorsRequests();
//
//       res.json({
//         totalRequests: this.corsRequests.length,
//         allowedRequests: stats.allowed,
//         blockedRequests: stats.blocked,
//         topOrigins: stats.topOrigins,
//         methodDistribution: stats.methodDistribution,
//         recentRequests: this.corsRequests.slice(-10).reverse()
//       });
//     });
//
//     // è·å–CORSè¯·æ±‚å†å²
//     this.server.get('/api/cors/history', (req: HttpRequest, res: HttpResponse) => {
//       const limit = parseInt(req.query.get('limit') || '50');
//       const offset = parseInt(req.query.get('offset') || '0');
//
//       const history = this.corsRequests
//         .slice(offset, offset + limit)
//         .reverse();
//
//       res.json({
//         history,
//         total: this.corsRequests.length,
//         limit,
//         offset
//       });
//     });
//
//     // æ¸…é™¤CORSç»Ÿè®¡
//     this.server.delete('/api/cors/stats', (req: HttpRequest, res: HttpResponse) => {
//       const count = this.corsRequests.length;
//       this.corsRequests = [];
//       this.nextId = 1;
//
//       res.json({
//         message: 'CORSç»Ÿè®¡å·²æ¸…é™¤',
//         clearedCount: count
//       });
//     });
//   }
//
//   /**
//    * åˆ†æCORSè¯·æ±‚ç»Ÿè®¡
//    */
//   private analyzeCorsRequests() {
//     const allowed = this.corsRequests.filter(req => req.allowed).length;
//     const blocked = this.corsRequests.length - allowed;
//
//     // ç»Ÿè®¡æ¥æº
//     const originCounts: Record<string, number> = {};
//     this.corsRequests.forEach(req => {
//       originCounts[req.origin] = (originCounts[req.origin] || 0) + 1;
//     });
//
//     const topOrigins = Object.entries(originCounts)
//       .sort(([, a], [, b]) => b - a)
//       .slice(0, 5)
//       .map(([origin, count]) => ({ origin, count }));
//
//     // ç»Ÿè®¡æ–¹æ³•
//     const methodCounts: Record<string, number> = {};
//     this.corsRequests.forEach(req => {
//       methodCounts[req.method] = (methodCounts[req.method] || 0) + 1;
//     });
//
//     return {
//       allowed,
//       blocked,
//       topOrigins,
//       methodDistribution: methodCounts
//     };
//   }
//
//   /**
//    * è®¾ç½®å…¨å±€é”™è¯¯å¤„ç†
//    */
//   private setupGlobalErrorHandler(): void {
//     if (!this.server) {
//       return;
//     }
//
//     const errorHandler: ErrorHandler = (error, req, res, next) => {
//       console.error(`ğŸš¨ [CORS Error Handler] ${req.method} ${req.path}: ${error.message}`);
//
//       if (res.isHeadersSent()) {
//         return next(error);
//       }
//
//       res.status(500).json({
//         error: 'CORS Server Error',
//         message: error.message,
//         timestamp: new Date().toISOString()
//       });
//     };
//
//     this.server.use(errorHandler);
//   }
//
//   /**
//    * æ‰“å°APIç«¯ç‚¹ä¿¡æ¯
//    */
//   private printApiEndpoints(info: ServerInfo): void {
//     const baseUrl = `http://${info.address}:${info.port}`;
//
//     console.log('\nğŸŒ CORS APIç«¯ç‚¹:');
//     console.log('='.repeat(50));
//
//     console.log('ğŸ“„ æ¼”ç¤ºé¡µé¢:');
//     console.log(`   GET  ${baseUrl}/cors-demo.html          - CORSæ¼”ç¤ºé¡µé¢`);
//     console.log(`   GET  ${baseUrl}/cors-test.html          - CORSæµ‹è¯•é¡µé¢`);
//
//     console.log('\nğŸ§ª CORSæµ‹è¯•:');
//     console.log(`   GET    ${baseUrl}/api/cors/simple       - ç®€å•è¯·æ±‚æµ‹è¯•`);
//     console.log(`   POST   ${baseUrl}/api/cors/preflight    - é¢„æ£€è¯·æ±‚æµ‹è¯•`);
//     console.log(`   POST   ${baseUrl}/api/cors/credentials  - å‡­è¯è¯·æ±‚æµ‹è¯•`);
//     console.log(`   PUT    ${baseUrl}/api/cors/custom-headers - è‡ªå®šä¹‰å¤´éƒ¨æµ‹è¯•`);
//
//     console.log('\nâš™ï¸  CORSé…ç½®:');
//     console.log(`   GET    ${baseUrl}/api/cors/config       - è·å–CORSé…ç½®`);
//     console.log(`   POST   ${baseUrl}/api/cors/config       - æ›´æ–°CORSé…ç½®`);
//     console.log(`   POST   ${baseUrl}/api/cors/test-origin  - æµ‹è¯•ç‰¹å®šæ¥æº`);
//
//     console.log('\nğŸ“Š CORSç»Ÿè®¡:');
//     console.log(`   GET    ${baseUrl}/api/cors/stats        - è·å–CORSç»Ÿè®¡`);
//     console.log(`   GET    ${baseUrl}/api/cors/history      - è·å–è¯·æ±‚å†å²`);
//     console.log(`   DELETE ${baseUrl}/api/cors/stats        - æ¸…é™¤ç»Ÿè®¡æ•°æ®`);
//
//     console.log('='.repeat(50));
//   }
// }