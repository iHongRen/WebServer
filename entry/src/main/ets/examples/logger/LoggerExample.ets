/**
 * @fileName : LoggerExample.ets
 * @author : @cxy
 * @date : 2025/10/29
 * @description : Loggerç¤ºä¾‹ - å±•ç¤ºæ—¥å¿—è®°å½•åŠŸèƒ½
 */

import { fileIo } from '@kit.CoreFileKit';
import { common } from '@kit.AbilityKit';
import {
  HttpServer,
  ErrorHandler,
  ServerInfo,
  ServerEventType,
  HttpRequest,
  HttpResponse,
  NextFunction,
} from '@cxy/webserver';
import { util } from '@kit.ArkTS';


/**
 * æ—¥å¿—è®°å½•æ¥å£
 */
interface LogRecord {
  id: number;
  timestamp: Date;
  level: 'debug' | 'info' | 'warn' | 'error';
  method: string;
  url: string;
  statusCode: number;
  responseTime: number;
  userAgent: string;
  ip: string;
  message: string;
}

interface LogStat {
  byLevel: Record<string, number>,
  byMethod: Record<string, number>,
  byStatusCode: Record<string, number>,
  averageResponseTime: number,
  errorRate: number
}

/**
 * Loggerç¤ºä¾‹ç±»
 * å±•ç¤ºå„ç§æ—¥å¿—è®°å½•åŠŸèƒ½å’Œæ ¼å¼
 */
export class LoggerExample {
  public logFormat: 'dev' | 'combined' | 'common' | 'short' | 'tiny' = 'dev';
  public logLevel: 'debug' | 'info' | 'warn' | 'error' = 'debug';
  // æ—¥å¿—è®°å½•
  public logRecords: LogRecord[] = [];
  private server: HttpServer | null = null;
  private nextLogId: number = 1;
  private logFilePath: string = ''

  init(context: common.UIAbilityContext) {
    this.logFilePath = context.filesDir + '/server.log';
  }


  /**
   * åˆå§‹åŒ–æœåŠ¡å™¨
   */
  public initializeServer(): void {
    this.server = new HttpServer();

    this.setupEventHandling();
    this.setupMiddleware();
    this.setupRoutes();
    this.setupGlobalErrorHandler();
  }

  /**
   * å¯åŠ¨æœåŠ¡å™¨
   */
  public async start(port: number): Promise<ServerInfo | null> {
    if (!this.server) {
      this.initializeServer();
    }

    const info = await this.server?.startServer(port);
    if (info) {
      console.log('âœ… æœåŠ¡å™¨å¯åŠ¨æˆåŠŸ!');
      console.log(`ğŸŒ è®¿é—®åœ°å€: http://${info.address}:${info.port}`);
      this.printApiEndpoints(info);
      return info;
    } else {
      console.error('âŒ å¯åŠ¨æœåŠ¡å™¨å¤±è´¥:');
      return null;
    }
  }

  /**
   * åœæ­¢æœåŠ¡å™¨
   */
  public async stop(): Promise<void> {
    if (this.server) {
      await this.server.stopServer();
    }
  }

  /**
   * è®¾ç½®äº‹ä»¶å¤„ç†
   */
  private setupEventHandling(): void {
    if (!this.server) {
      return;
    }

    this.server.onError((error) => {
      this.writeLog('error', `æœåŠ¡å™¨é”™è¯¯: ${JSON.stringify(error)}`, {
        errorType: error.type
      });
    });

    this.server.on(ServerEventType.SERVER_STARTED, (event) => {
      this.writeLog('info', 'æœåŠ¡å™¨å¯åŠ¨æˆåŠŸ', event.data);
    });

    this.server.on(ServerEventType.SERVER_STOPPED, () => {
      this.writeLog('info', 'æœåŠ¡å™¨å·²åœæ­¢');
    });
  }

  /**
   * è®¾ç½®å…¨å±€é”™è¯¯å¤„ç†
   */
  private setupGlobalErrorHandler(): void {
    if (!this.server) {
      return;
    }

    const errorHandler: ErrorHandler = (error, req, res, next) => {
      this.writeLog('error', `å…¨å±€é”™è¯¯å¤„ç†: ${error.message}`, {
        path: req.path,
        method: req.method,
        error: error.message
      });

      if (res.isHeadersSent()) {
        return next(error);
      }

      res.status(500).json({
        error: 'Logger Server Error',
        message: error.message,
        timestamp: new Date().toISOString()
      });
    };

    this.server.use(errorHandler);
  }


  /**
   * é…ç½®ä¸­é—´ä»¶
   */
  private setupMiddleware(): void {
    if (!this.server) {
      return;
    }

    this.server.cors();

    // è‡ªå®šä¹‰æ—¥å¿—ä¸­é—´ä»¶
    this.server.use((req: HttpRequest, res: HttpResponse, next: NextFunction) => {
      const startTime = Date.now();

      // è®°å½•è¯·æ±‚å¼€å§‹
      this.writeLog('debug', `è¯·æ±‚å¼€å§‹: ${req.method} ${req.path}`, {
        method: req.method,
        url: req.path,
        userAgent: req.userAgent,
        ip: req.ip
      });

      // ç›‘å¬å“åº”å®Œæˆ
      res.onFinish((statusCode, responseSize) => {
        const responseTime = Date.now() - startTime;

        // è®°å½•è¯¦ç»†çš„è¯·æ±‚æ—¥å¿—
        const logRecord: LogRecord = {
          id: this.nextLogId++,
          timestamp: new Date(),
          level: statusCode >= 400 ? 'error' : statusCode >= 300 ? 'warn' : 'info',
          method: req.method,
          url: req.url,
          statusCode,
          responseTime,
          userAgent: req.userAgent,
          ip: req.ip,
          message: this.formatLogMessage(req, statusCode, responseTime, responseSize)
        };

        this.logRecords.push(logRecord);

        // é™åˆ¶æ—¥å¿—è®°å½•æ•°é‡
        if (this.logRecords.length > 1000) {
          this.logRecords = this.logRecords.slice(-1000);
        }

        // å†™å…¥æ–‡ä»¶æ—¥å¿—
        this.writeToFile(logRecord);
        console.log(`ğŸ“ ${logRecord.message}`);
      });

      next();
    });

    this.server.auto();
  }

  /**
   * æ ¼å¼åŒ–æ—¥å¿—æ¶ˆæ¯
   */
  private formatLogMessage(req: HttpRequest, statusCode: number, responseTime: number, responseSize: number): string {
    const timestamp = new Date().toISOString();

    switch (this.logFormat) {
      case 'combined':
        return `${req.ip} - - [${timestamp}] "${req.method} ${req.url} HTTP/1.1" ${statusCode} ${responseSize} "${req.referer}" "${req.userAgent}"`;

      case 'common':
        return `${req.ip} - - [${timestamp}] "${req.method} ${req.url} HTTP/1.1" ${statusCode} ${responseSize}`;

      case 'short':
        return `${req.ip} ${req.method} ${req.url} HTTP/1.1 ${statusCode} ${responseSize} - ${responseTime}ms`;

      case 'tiny':
        return `${req.method} ${req.url} ${statusCode} ${responseSize} - ${responseTime}ms`;

      case 'dev':
      default:
        const statusColor = statusCode >= 400 ? 'ğŸ”´' : statusCode >= 300 ? 'ğŸŸ¡' : 'ğŸŸ¢';
        return `${statusColor} ${req.method} ${req.url} ${statusCode} ${responseTime}ms - ${responseSize}b`;
    }
  }

  /**
   * å†™å…¥æ—¥å¿—
   */
  private writeLog(level: 'debug' | 'info' | 'warn' | 'error', message: string, data?: ESObject): void {
    const logLevels = {
      'debug': 0,
      'info': 1,
      'warn': 2,
      'error': 3
    } as Record<string, number>
    const configLevel = logLevels[this.logLevel];
    const messageLevel = logLevels[level];

    if (messageLevel >= configLevel) {
      const timestamp = new Date().toISOString();
      const logMessage = `[${timestamp}] [${level.toUpperCase()}] ${message}`;

      if (data) {
        console.log(logMessage, data);
      } else {
        console.log(logMessage);
      }


      this.writeToFile({
        id: this.nextLogId++,
        timestamp: new Date(),
        level,
        method: '',
        url: '',
        statusCode: 0,
        responseTime: 0,
        userAgent: '',
        ip: '',
        message: logMessage
      });

    }
  }

  /**
   * å†™å…¥æ–‡ä»¶æ—¥å¿—
   */
  private async writeToFile(logRecord: LogRecord): Promise<void> {
    try {
      const logLine = `${logRecord.message}\n`;
      const file = await fileIo.open(this.logFilePath,
        fileIo.OpenMode.CREATE | fileIo.OpenMode.WRITE_ONLY | fileIo.OpenMode.APPEND);
      await fileIo.write(file.fd, new util.TextEncoder().encodeInto(logLine).buffer);
      await fileIo.close(file.fd);
    } catch (error) {
      console.error('å†™å…¥æ—¥å¿—æ–‡ä»¶å¤±è´¥:', error);
    }
  }

  /**
   * é…ç½®è·¯ç”±
   */
  private setupRoutes(): void {
    this.setupLogRoutes();
    this.setupTestRoutes();
  }

  /**
   * æ—¥å¿—æŸ¥è¯¢è·¯ç”±
   */
  private setupLogRoutes(): void {
    if (!this.server) {
      return;
    }

    // è·å–æ—¥å¿—è®°å½•
    this.server.get('/api/logs', (req: HttpRequest, res: HttpResponse) => {
      const limit = parseInt(req.query.get('limit') || '50');
      const offset = parseInt(req.query.get('offset') || '0');
      const level = req.query.get('level');
      const method = req.query.get('method');

      let filteredLogs = this.logRecords;

      if (level) {
        filteredLogs = filteredLogs.filter(log => log.level === level);
      }

      if (method) {
        filteredLogs = filteredLogs.filter(log => log.method === method);
      }

      const logs = filteredLogs
        .slice(offset, offset + limit)
        .reverse();

      res.json({
        logs,
        total: filteredLogs.length,
        limit,
        offset,
        level,
        method
      });
    });

    // è·å–æ—¥å¿—ç»Ÿè®¡
    this.server.get('/api/logs/stats', (req: HttpRequest, res: HttpResponse) => {
      const stats = this.analyzeLogStats();

      res.json({
        totalLogs: this.logRecords.length,
        byLevel: stats.byLevel,
        byMethod: stats.byMethod,
        byStatusCode: stats.byStatusCode,
        averageResponseTime: stats.averageResponseTime,
        errorRate: stats.errorRate
      });
    });

    // æ¸…é™¤æ—¥å¿—è®°å½•
    this.server.delete('/api/logs', (req: HttpRequest, res: HttpResponse) => {
      const count = this.logRecords.length;
      this.logRecords = [];
      this.nextLogId = 1;

      res.json({
        message: 'Log records cleared',
        clearedCount: count
      });
    });
  }


  /**
   * æµ‹è¯•è·¯ç”±
   */
  private setupTestRoutes(): void {
    if (!this.server) {
      return;
    }

    // æµ‹è¯•ä¸åŒçº§åˆ«çš„æ—¥å¿—
    this.server.post('/api/logs/test/:level', (req: HttpRequest, res: HttpResponse) => {
      const level = req.params['level'] as 'debug' | 'info' | 'warn' | 'error';
      const message = `æµ‹è¯•${level}çº§åˆ«æ—¥å¿—`;

      this.writeLog(level, message, {
        testData: req.body,
        triggeredBy: 'api'
      });

      res.json({
        message: `${level} log generated`,
        logLevel: level,
        timestamp: new Date().toISOString()
      });
    });

    // æ¨¡æ‹Ÿæ…¢è¯·æ±‚
    this.server.get('/api/test/slow', (req: HttpRequest, res: HttpResponse) => {
      const delay = parseInt(req.query.get('delay') || '1000');

      setTimeout(() => {
        res.json({
          message: 'Slow request completed',
          delay,
          timestamp: new Date().toISOString()
        });
      }, delay);
    });

    // æ¨¡æ‹Ÿé”™è¯¯è¯·æ±‚
    this.server.get('/api/test/error/:code', (req: HttpRequest, res: HttpResponse) => {
      const statusCode = parseInt(req.params['code']);

      res.status(statusCode).json({
        error: `Simulated ${statusCode} error`,
        timestamp: new Date().toISOString()
      });
    });
  }

  /**
   * åˆ†ææ—¥å¿—ç»Ÿè®¡
   */
  private analyzeLogStats(): LogStat {
    const byLevel: Record<string, number> = {};
    const byMethod: Record<string, number> = {};
    const byStatusCode: Record<string, number> = {};
    let totalResponseTime = 0;
    let errorCount = 0;

    this.logRecords.forEach(log => {
      byLevel[log.level] = (byLevel[log.level] || 0) + 1;
      byMethod[log.method] = (byMethod[log.method] || 0) + 1;
      byStatusCode[log.statusCode] = (byStatusCode[log.statusCode] || 0) + 1;

      totalResponseTime += log.responseTime;

      if (log.statusCode >= 400) {
        errorCount++;
      }
    });

    return {
      byLevel,
      byMethod,
      byStatusCode,
      averageResponseTime: this.logRecords.length > 0 ? totalResponseTime / this.logRecords.length : 0,
      errorRate: this.logRecords.length > 0 ? (errorCount / this.logRecords.length) * 100 : 0
    }
  }


  /**
   * æ‰“å°APIç«¯ç‚¹ä¿¡æ¯
   */
  private printApiEndpoints(info: ServerInfo): void {
    const baseUrl = `http://${info.address}:${info.port}`;

    console.log('\nğŸ“ Logger APIç«¯ç‚¹:');
    console.log('='.repeat(50));

    console.log('\nğŸ“Š æ—¥å¿—æŸ¥è¯¢:');
    console.log(`   GET    ${baseUrl}/api/logs             - è·å–æ—¥å¿—è®°å½•`);
    console.log(`   GET    ${baseUrl}/api/logs/stats       - è·å–æ—¥å¿—ç»Ÿè®¡`);
    console.log(`   DELETE ${baseUrl}/api/logs             - æ¸…é™¤æ—¥å¿—è®°å½•`);

    console.log('\nğŸ§ª æ—¥å¿—æµ‹è¯•:');
    console.log(`   POST   ${baseUrl}/api/logs/test/:level - æµ‹è¯•æ—¥å¿—çº§åˆ«`);
    console.log(`   GET    ${baseUrl}/api/test/slow        - æ…¢è¯·æ±‚æµ‹è¯•`);
    console.log(`   GET    ${baseUrl}/api/test/error/:code - é”™è¯¯è¯·æ±‚æµ‹è¯•`);

    console.log('='.repeat(50));
  }
}