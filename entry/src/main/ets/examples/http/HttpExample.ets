/**
 * @fileName : HttpExample.ets
 * @author : @cxy
 * @date : 2025/10/29
 * @description : HTTPæœåŠ¡å™¨ç¤ºä¾‹ - å±•ç¤ºWebServerçš„å„ç§åŠŸèƒ½
 */

import { fileIo } from '@kit.CoreFileKit';
import { common } from '@kit.AbilityKit';
import {
  HttpServer,
  ErrorHandler,
  ServerInfo,
  ServerEventType,
  HttpRequest,
  HttpResponse,
} from '@cxy/webserver';


/**
 * ç”¨æˆ·æ•°æ®æ¥å£
 */
interface User {
  id: number;
  name: string;
}


/**
 * HTTPæœåŠ¡å™¨ç¤ºä¾‹ç±»
 * æä¾›å®Œæ•´çš„RESTful APIå’Œæ–‡ä»¶ä¸Šä¼ åŠŸèƒ½æ¼”ç¤º
 */
export class HttpExample {
  public staticRoot: string = ''
  private server: HttpServer | null = null;
  private context?: common.UIAbilityContext;
  // æ¨¡æ‹Ÿæ•°æ®å­˜å‚¨
  private users: User[] = [];
  private nextUserId: number = 1;

  init(context: common.UIAbilityContext) {
    this.context = context;
    this.staticRoot = context.filesDir + '/static'
    this.users = [
      {
        id: 1,
        name: 'cxy',
      },
      {
        id: 2,
        name: 'ihongren',
      }
    ];
    this.nextUserId = 3;
  }

  /**
   * è®¾ç½®é™æ€æ–‡ä»¶
   */
  public async setupStaticFiles(): Promise<void> {
    // æ£€æŸ¥å¹¶åˆ›å»ºé™æ€æ–‡ä»¶ç›®å½•
    const access = await fileIo.access(this.staticRoot);
    if (!access) {
      await fileIo.mkdir(this.staticRoot);
    }
    // å¤åˆ¶é™æ€æ–‡ä»¶åˆ°æ²™ç®±ç›®å½•
    await this.copyStaticFile('index.html');
    await this.copyStaticFile('upload.html');
  }

  /**
   * åˆå§‹åŒ–æœåŠ¡å™¨
   */
  public async initializeServer(): Promise<void> {
    this.server = new HttpServer();
    // è®¾ç½®æœåŠ¡å™¨äº‹ä»¶å¤„ç†
    this.setupEventHandling();

    // é…ç½®ä¸­é—´ä»¶
    this.setupMiddleware();

    // é…ç½®è·¯ç”±
    this.setupRoutes();

    // è®¾ç½®å…¨å±€é”™è¯¯å¤„ç†ä¸­é—´ä»¶
    this.setupGlobalErrorHandler();

    // é™æ€æ–‡ä»¶
    await this.setupStaticFiles();
  }

  /**
   * å¯åŠ¨æœåŠ¡å™¨
   */
  public async start(port: number): Promise<ServerInfo | null> {
    if (!this.server) {
      await this.initializeServer();
    }

    const info = await this.server?.startServer(port);
    if (info) {
      console.log('âœ… HTTPæœåŠ¡å™¨å¯åŠ¨æˆåŠŸ!');
      console.log(`ğŸŒ è®¿é—®åœ°å€: http://${info.address}:${info.port}`);
      this.printApiEndpoints(info);
      return info;
    } else {
      console.error('âŒ å¯åŠ¨æœåŠ¡å™¨å¤±è´¥:');
      return null;
    }
  }

  /**
   * åœæ­¢æœåŠ¡å™¨
   */
  public async stop(): Promise<void> {
    if (this.server) {
      await this.server.stopServer();
    }
  }

  /**
   * å¤åˆ¶é™æ€æ–‡ä»¶åˆ°æ²™ç®±ç›®å½•
   */
  private async copyStaticFile(fileName: string): Promise<void> {
    const buffer = await this.context?.resourceManager.getRawFileContent(fileName);
    const filePath = `${this.staticRoot}/${fileName}`;

    const file = await fileIo.open(filePath,
      fileIo.OpenMode.CREATE | fileIo.OpenMode.WRITE_ONLY | fileIo.OpenMode.TRUNC);
    await fileIo.write(file.fd, buffer?.buffer);
    await fileIo.close(file.fd);
  }


  /**
   * è®¾ç½®é”™è¯¯å¤„ç†å’Œäº‹ä»¶ç›‘å¬
   */
  private setupEventHandling(): void {
    if (!this.server) {
      return;
    }

    // ç›‘å¬æœåŠ¡å™¨é”™è¯¯
    this.server.onError((error) => {
      console.error(`ğŸš¨ æœåŠ¡å™¨é”™è¯¯ [${error.type}]: ${JSON.stringify(error.error)}`);
    });

    // ç›‘å¬æœåŠ¡å™¨äº‹ä»¶
    this.server.on(ServerEventType.SERVER_STARTED, (event) => {
      console.log('âœ… æœåŠ¡å™¨å¯åŠ¨æˆåŠŸ:', JSON.stringify(event.data));
    });

    this.server.on(ServerEventType.SERVER_STOPPED, () => {
      console.log('ğŸ›‘ æœåŠ¡å™¨å·²åœæ­¢');
    });
  }

  /**
   * é…ç½®ä¸­é—´ä»¶
   */
  private setupMiddleware(): void {
    if (!this.server) {
      return;
    }

    // 1. æ—¥å¿—ä¸­é—´ä»¶ï¼ˆæœ€å…ˆæ‰§è¡Œï¼‰
    this.server.logger({
      format: 'dev',
      stream: (log: string) => {
        console.log(`ğŸ“ ${log}`);
      }
    });

    // 2. CORSä¸­é—´ä»¶
    this.server.cors({
      origin: '*'
    });

    // 3. è¯·æ±‚ä½“è§£æä¸­é—´ä»¶
    this.server.auto();

    // 4. é™æ€æ–‡ä»¶æœåŠ¡ï¼ˆåœ¨APIè·¯ç”±ä¹‹å‰ï¼‰
    this.server.serveStatic(this.staticRoot);
  }

  /**
   * é…ç½®æ‰€æœ‰è·¯ç”±
   */
  private setupRoutes(): void {
    this.setupApiRoutes();
    this.setupFileRoutes();
  }


  /**
   * é…ç½®APIè·¯ç”±
   */
  private setupApiRoutes(): void {
    if (!this.server) {
      return;
    }

    // ==================== ç”¨æˆ·ç®¡ç†API ====================

    // GET /api/users - è·å–æ‰€æœ‰ç”¨æˆ·ï¼ˆæ”¯æŒåˆ†é¡µå’Œæœç´¢ï¼‰
    this.server.get('/api/users', (req: HttpRequest, res: HttpResponse) => {
      const page = parseInt(req.query.get('page') || '1');
      const limit = parseInt(req.query.get('limit') || '10');
      const search = req.query.get('search') || '';

      let filteredUsers = this.users;

      // æœç´¢åŠŸèƒ½
      if (search) {
        filteredUsers = this.users.filter(user =>
        user.name.toLowerCase().includes(search.toLowerCase())
        );
      }

      // åˆ†é¡µ
      const startIndex = (page - 1) * limit;
      const endIndex = startIndex + limit;
      const paginatedUsers = filteredUsers.slice(startIndex, endIndex);

      res.json({
        users: paginatedUsers,
        pagination: {
          page,
          limit,
          total: filteredUsers.length,
          totalPages: Math.ceil(filteredUsers.length / limit)
        } as ESObject,
        search
      });
    });

    // GET /api/users/:id - è·å–å•ä¸ªç”¨æˆ·
    this.server.get('/api/users/:id', (req: HttpRequest, res: HttpResponse) => {
      const userId = parseInt(req.params['id']);
      const user = this.users.find(u => u.id === userId);

      if (user) {
        res.json({ user });
      } else {
        res.status(404).json({
          error: 'User not found',
          userId
        });
      }
    });

    // POST /api/users - åˆ›å»ºæ–°ç”¨æˆ·
    this.server.post('/api/users', (req, res, next) => {
      const data = req.body as Record<string, string>;

      if (!data.name) {
        res.status(400).json({
          error: 'Name is required'
        });
        return
      }

      const newUser: User = {
        id: this.nextUserId++,
        name: data.name,
      };

      this.users.push(newUser);
      console.log('ğŸ‘¤ åˆ›å»ºæ–°ç”¨æˆ·:', JSON.stringify(newUser));

      res.status(201).json({
        message: 'User created successfully',
        user: newUser
      });
    });

    // PUT /api/users/:id - æ›´æ–°ç”¨æˆ·
    this.server.put('/api/users/:id', (req, res, next) => {
      const userId = parseInt(req.params['id']);
      const userIndex = this.users.findIndex(u => u.id === userId);

      if (userIndex === -1) {
        res.status(404).json({
          error: 'User not found',
          userId
        });
        return
      }

      const data = req.body as Record<string, string>;
      if (data.name) {
        this.users[userIndex].name = data.name;
      }
      res.json({
        message: 'User updated successfully',
        user: this.users[userIndex]
      });
    });

    // DELETE /api/users/:id - åˆ é™¤ç”¨æˆ·
    this.server.delete('/api/users/:id', (req, res, next) => {
      const userId = parseInt(req.params['id']);
      const userIndex = this.users.findIndex(u => u.id === userId);

      if (userIndex === -1) {
        res.status(404).json({
          error: 'User not found',
          userId
        });
        return
      }

      const deletedUser = this.users.splice(userIndex, 1)[0];

      res.json({
        message: 'User deleted successfully',
        user: deletedUser
      });
    });
  }

  /**
   * é…ç½®æ–‡ä»¶ç›¸å…³è·¯ç”±
   */
  private setupFileRoutes(): void {
    if (!this.server) {
      return;
    }

    // POST /api/upload - æ–‡ä»¶ä¸Šä¼ 
    this.server.post('/api/upload', async (req: HttpRequest, res: HttpResponse, next) => {
      try {
        const uploadedFile = req.files?.['uploadFile'];

        if (!uploadedFile) {
          return res.status(400).json({
            error: 'No file uploaded',
            hint: 'Use form field name "uploadFile"'
          });
        }

        // ç”Ÿæˆå”¯ä¸€æ–‡ä»¶å
        const timestamp = Date.now();
        const fileName = `${timestamp}_${uploadedFile.fileName}`;
        const filePath = `${this.context?.filesDir}/${fileName}`;

        // ä¿å­˜æ–‡ä»¶
        const file = await fileIo.open(filePath,
          fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE);
        await fileIo.write(file.fd, uploadedFile.data);
        await fileIo.close(file.fd);

        console.log(`ğŸ“ æ–‡ä»¶ä¸Šä¼ æˆåŠŸ: ${fileName}`);

        res.json({
          message: 'File uploaded successfully',
          file: {
            originalName: uploadedFile.fileName,
            savedName: fileName,
            size: uploadedFile.data.byteLength,
            contentType: uploadedFile.contentType,
            uploadTime: new Date().toISOString(),
            path: filePath
          } as ESObject
        });
      } catch (error) {
        console.error('âŒ æ–‡ä»¶ä¸Šä¼ å¤±è´¥:', error);
        next(error);
      }
    });

    // GET /api/files - è·å–å·²ä¸Šä¼ æ–‡ä»¶åˆ—è¡¨
    this.server.get('/api/files', async (req: HttpRequest, res: HttpResponse) => {
      try {
        if (this.context) {
          const files = await fileIo.listFile(this.context.filesDir);
          const fileList: Record<string, string>[] = files
            .filter(file => !file.startsWith('.'))
            .map(file => {
              const item: Record<string, string> = {
                'name': file,
                'path': `${this.context?.filesDir}/${file}`
              }
              return item
            });

          res.json({
            files: fileList,
            count: fileList.length
          });
        } else {
          res.status(500).json({ error: 'context is undefined' });
        }
      } catch (error) {
        console.error('âŒ è·å–æ–‡ä»¶åˆ—è¡¨å¤±è´¥:', error);
        res.status(500).json({ error: 'Failed to list files' });
      }
    });
  }


  /**
   * è®¾ç½®å…¨å±€é”™è¯¯å¤„ç†ä¸­é—´ä»¶, éœ€æ”¾åˆ°æ‰€æœ‰è·¯ç”±ä¹‹åæ³¨å†Œ
   */
  private setupGlobalErrorHandler(): void {
    if (!this.server) {
      return;
    }

    const errorHandler: ErrorHandler = (error, req, res, next) => {
      console.error(`ğŸš¨ [Global Error Handler] ${req.method} ${req.path}: ${error.message}`);

      if (res.isHeadersSent()) {
        return next(error);
      }

      // æ ¹æ®é”™è¯¯ç±»å‹è¿”å›ä¸åŒçš„çŠ¶æ€ç 
      let statusCode = 500;
      let errorType = 'Internal Server Error';

      if (error.message.includes('Validation')) {
        statusCode = 400;
        errorType = 'Validation Error';
      } else if (error.message.includes('timeout')) {
        statusCode = 408;
        errorType = 'Request Timeout';
      }

      res.status(statusCode).json({
        error: errorType,
        message: error.message,
        timestamp: new Date().toISOString(),
        path: req.path,
        method: req.method
      });
    };

    this.server.use(errorHandler);
  }

  /**
   * æ‰“å°APIç«¯ç‚¹ä¿¡æ¯
   */
  private printApiEndpoints(info: ServerInfo): void {
    const baseUrl = `http://${info.address}:${info.port}`;

    console.log('\nğŸ“‹ å¯ç”¨çš„APIç«¯ç‚¹:');
    console.log('='.repeat(50));

    // é™æ€æ–‡ä»¶
    console.log('ğŸ“„ é™æ€æ–‡ä»¶:');
    console.log(`   GET  ${baseUrl}/                    - é¦–é¡µ`);
    console.log(`   GET  ${baseUrl}/upload.html         - æ–‡ä»¶ä¸Šä¼ é¡µé¢`);

    // ç”¨æˆ·ç®¡ç†API
    console.log('\nğŸ‘¥ ç”¨æˆ·ç®¡ç†API:');
    console.log(`   GET    ${baseUrl}/api/users         - è·å–ç”¨æˆ·åˆ—è¡¨`);
    console.log(`   GET    ${baseUrl}/api/users/:id     - è·å–å•ä¸ªç”¨æˆ·`);
    console.log(`   POST   ${baseUrl}/api/users         - åˆ›å»ºç”¨æˆ·`);
    console.log(`   PUT    ${baseUrl}/api/users/:id     - æ›´æ–°ç”¨æˆ·`);
    console.log(`   DELETE ${baseUrl}/api/users/:id     - åˆ é™¤ç”¨æˆ·`);

    // æ–‡ä»¶ç®¡ç†API
    console.log('\nğŸ“ æ–‡ä»¶ç®¡ç†API:');
    console.log(`   POST   ${baseUrl}/api/upload        - ä¸Šä¼ æ–‡ä»¶`);
    console.log(`   GET    ${baseUrl}/api/files         - è·å–æ–‡ä»¶åˆ—è¡¨`);

    console.log('='.repeat(50));
  }
}